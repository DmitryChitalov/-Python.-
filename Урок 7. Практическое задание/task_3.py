"""
3. Массив размером 2m + 1, где m – натуральное число, заполнен случайным образом.
Найдите в массиве медиану. Медианой называется элемент ряда, делящий его на
две равные части: в одной находятся элементы, которые не меньше медианы,
в другой – не больше медианы. Задачу можно решить без сортировки исходного
массива. Но если это слишком сложно, то используйте метод сортировки,
который не рассматривался на уроках
"""
from random import randint

M = 5
LST = [randint(0, 50) for _ in range(2 * M + 1)]


def median(lst, old_lst):
    left_lst_old = [i for i in old_lst if i < lst[0]]
    right_lst_old = [i for i in old_lst if i > lst[0]]
    cnt = lst.count(lst[0])
    if cnt > 1:
        for i in range(cnt - 1):
            if len(left_lst_old) > len(right_lst_old):
                right_lst_old.append(lst[0])
            else:
                left_lst_old.append(lst[0])

    left_lst = [i for i in lst if i < lst[0]]
    right_lst = [i for i in lst if i > lst[0]]

    if len(left_lst_old) == len(right_lst_old):
        return lst[0]

    elif len(left_lst_old) > len(right_lst_old):
        return median(left_lst, old_lst)
    else:
        return median(right_lst, old_lst)


print(f'В массиве {LST} медианой является число {median(LST, LST)}')


"""
Вычисление происходит с помошью рекурсии. Берется 0-й элемент массива. Находятся все элементы меньше него
и больше него. Если элемент присутствует несколько раз, то элементы раскидываются по левому и правому списку
для уравновешивания. Если списки равны по длинне, то медиана найдена. Если нет, то надо брать следующий элемент,
но тогда пришлось бы перебирать все, пока не попадется нужный. Что бы ускорить процесс, мы паралельно создаем еще
правый и левый список, без повторов опорного элемента и тех значений которые мы уже отсекли, и если правый список 
длиннее левого, то значит что медиана находится там, именно его мы и отправляем рекурсивно в функцию, которая снова
делит список и ищет медиану, сверяясь с старым, полным списком. Так как мы каждый раз отсекаем диапазон чисел, 
поиск происходит быстро.
"""