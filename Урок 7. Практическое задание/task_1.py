"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы. Сортировка должна быть реализована в
виде функции. Обязательно доработайте алгоритм (сделайте его умнее).
Идея доработки: если за проход по списку не совершается ни одной сортировки, то завершение
Обязательно сделайте замеры времени обеих реализаций

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию
"""


import random
from timeit import timeit


def bubble_sort(orig_list):
    """ Сортировка методом пузырька по убыванию без оптимизации """
    n = 1
    count_operations = 0
    while n < len(orig_list):
        for i in range(len(orig_list) - n):
            count_operations += 1
            if orig_list[i] < orig_list[i + 1]:
                orig_list[i], orig_list[i + 1] = orig_list[i + 1], orig_list[i]
        n += 1
    return orig_list, count_operations


def bubble_sort_opt(orig_list):
    """ Сортировка методом пузырька по убыванию c оптимизации """
    n = 1
    count_operations = 0
    is_sorted = False
    while not is_sorted:
        is_sorted = True
        for i in range(len(orig_list) - n):
            count_operations += 1
            if orig_list[i] < orig_list[i + 1]:
                is_sorted = False
                orig_list[i], orig_list[i + 1] = orig_list[i + 1], orig_list[i]
        n += 1
    return orig_list, count_operations


def checker(func):
    """ Функция для проверки алгоритмов """
    o_list = [random.randint(-100, 100) for _ in range(1000)]
    return func(o_list)


if __name__ == '__main__':
    ORIG_LIST = [random.randint(-100, 100) for _ in range(40)]
    ORIG_LIST2 = ORIG_LIST.copy()
    print('Исходный массив:', ORIG_LIST)
    RESULT = bubble_sort(ORIG_LIST)
    print(f'Без оптимизации массив был отсортирован за {RESULT[1]} итераций.')
    print(' Отсортированный массив:', RESULT[0])
    RESULT = bubble_sort_opt(ORIG_LIST2)
    print(
        f'После оптимизации массив был отсортирован за {RESULT[1]} итераций.')
    print(' Отсортированный массив:', RESULT[0])

    print('Замеры времени для обычного алгоритма:')
    print(
        timeit(
            'checker(bubble_sort)',
            setup="from __main__ import checker, bubble_sort",
            number=100))
    print('Замеры времени для оптимизированного алгоритма:')
    print(
        timeit(
            'checker(bubble_sort_opt)',
            setup="from __main__ import checker, bubble_sort_opt",
            number=100))

# >>>
"""
Исходный массив: [-79, -6, -97, 66, 87, -95, -20, 51, 90, -72, 83, -71, 92, -9, 59, -3, 52, -17, 26, 97, 23, -13, 69, -54, 59, -31, 66, -61, 18, 86, -56, -86, -14, 90, -26, 59, -92, -2, 9, 74]
Без оптимизации массив был отсортирован за 780 итераций.
 Отсортированный массив: [97, 92, 90, 90, 87, 86, 83, 74, 69, 66, 66, 59, 59, 59, 52, 51, 26, 23, 18, 9, -2, -3, -6, -9, -13, -14, -17, -20, -26, -31, -54, -56, -61, -71, -72, -79, -86, -92, -95, -97]
После оптимизации массив был отсортирован за 759 итераций.
 Отсортированный массив: [97, 92, 90, 90, 87, 86, 83, 74, 69, 66, 66, 59, 59, 59, 52, 51, 26, 23, 18, 9, -2, -3, -6, -9, -13, -14, -17, -20, -26, -31, -54, -56, -61, -71, -72, -79, -86, -92, -95, -97]
Замеры времени для обычного алгоритма:
9.274891132008634
Замеры времени для оптимизированного алгоритма:
8.943127239996102


Оптимизация алгоритма позволят сократить количество итераций в среднем на 5%
что даёт незначительный выигрыш по времени.
Замеры времени на больших массивах (1000 элементов и более)
показывают, что оба алгоритма - как обычный так и оптимизированный
имеют крайне низкую эффективность.
Таким образом оба эти алгоритма можно применять лишь на малых массивах, размером
до 100 элементов.
"""