"""
2.	Написать программу сложения и умножения двух шестнадцатеричных чисел.
При этом каждое число представляется как массив, элементы которого это цифры числа.
Например, пользователь ввёл A2 и C4F. Сохранить их как [‘A’, ‘2’] и [‘C’, ‘4’, ‘F’] соответственно.
Сумма чисел из примера: [‘C’, ‘F’, ‘1’], произведение - [‘7’, ‘C’, ‘9’, ‘F’, ‘E’].

Подсказка:
Для решения задачи обязательно примените какую-нибудь коллекцию из модуля collections
Для лучшее освоения материала можете даже сделать несколько решений этого задания,
применив несколько коллекций из модуля collections
Также попробуйте решить задачу вообще без collections и применить только ваши знания по ООП
(в частности по перегрузке методов)
"""

from collections import deque


def add(x, y):
    """
    Сложение шестнадцатиричных чисел
    """
    # info: если при сложении происходит выход за рамки системы
    # исчисления (в шестнадцатиричной 15-F предел), то из суммы вычитается 16
    # и к следующему разряду прибавляется единица

    # т.к. нам придется использовать и текст и числа для определения и вставки
    # то словарь заполняем обоими вариантами, чтобы не реализовывать поиск по значению
    hex_numbers = {
        0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7',
        8: '8', 9: '9', 10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F',
        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,
        '8': 8, '9': 9, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15
    }

    # если по длине второе число больше первого, то меняем местами
    if len(y) > len(x):
        x, y = y, x

    # результирующий список (очередь)
    result_deque = deque()
    # единица для добавления к следующему разряду, по умолчанию 0
    digit = 0
    # будем выполнять действия пока существует число (очередь) 'x'
    while x:
        # проверяем существует ли еще число 'y'
        if y:
            # ищем в hex_numbers наши числа(их часть) по ключу,
            # складываем, а также удаляем из очередей 'x' и 'y'
            tmp = hex_numbers[x.pop()] + hex_numbers[y.pop()] + digit
        else:
            # если второй очереди уже нет, до добавляем остатки первого
            tmp = hex_numbers[x.pop()] + digit

        # обнуляем переменную для последующего использования в цикле
        digit = 0

        # если сумма оказалась больше 16
        if tmp > 16:
            # то слева к результату добавляем (сумму - 16)
            result_deque.appendleft(hex_numbers[tmp - 16])
            # переводим единицу на следующий разряд
            digit = 1
        else:
            # иначе добавляем сумму
            result_deque.appendleft(hex_numbers[tmp])

    # если переменная для переноса разрядности равна 1
    # то добавляем ее слева к очереди
    if digit == 1:
        result_deque.appendleft('1')

    # возвращаем очередь
    return result_deque


def mul(x, y):
    """
    Сложение шестнадцатиричных чисел
    """
    # info: если при умножении происходит выход за рамки системы
    # исчисления (в шестнадцатиричной 15-F предел), то произведение делим нацело на 16
    # остаток пишем в число, а результат прибавляем к следующему разряду

    # т.к. нам придется использовать и текст и числа для определения и вставки
    # то словарь заполняем обоими вариантами, чтобы не реализовывать поиск по значению
    hex_numbers = {
        0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7',
        8: '8', 9: '9', 10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F',
        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,
        '8': 8, '9': 9, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15
    }

    # если по длине второе число больше первого, то меняем местами
    if len(y) > len(x):
        x, y = y, x

    # результирующий список (очередь)
    result_deque = deque()
    # временный список (очередь) для промежуточных вычислений
    tmp_deque = deque()
    # временный список для хранения чисел (очередей)
    tmp_list = list()
    # единица для добавления к следующему разряду, по умолчанию 0
    digit = 0

    # проходим очередь 'y' и удаляем элементы
    for i in range(len(y)):
        # получаем элемент для вычислений
        el = hex_numbers[y.pop()]
        # проходим очередь 'x' с конца
        for j in range(len(x) - 1, -1, -1):
            # в переменную пишем произведение элементов + остаток
            tmp = hex_numbers[x[j]] * el + digit
            # если произведение нацело не делится на 16
            # то остаток добавляем к числу
            tmp_deque.appendleft(hex_numbers[tmp % 16])
            # записываем результат в следующий разряд
            digit = tmp // 16
        # если остался разряд, то добавляем к очереди
        if digit != 0:
            tmp_deque.appendleft(hex_numbers[digit])
        # если в списке уже есть числа, то добавляем '0'
        # в начало числа, для последующих сложений
        if len(tmp_list) != 0:
            # количество нулей зависит от количества чисел в списке
            for k in range(len(tmp_list)):
                tmp_deque.append('0')
        # обнуляем разряд
        digit = 0
        # копируем число в список
        tmp_list.append(tmp_deque.copy())
        # обнуляем очередь
        tmp_deque.clear()

    # для конечного результата нужно сложить все числа в списке
    # воспользуемся уже готовой функцией
    for i in range(len(tmp_list)):
        tmp_deque = add(tmp_deque, tmp_list[i])

    # добавляем результат в result_deque
    result_deque = tmp_deque.copy()

    # возвращаем очередь
    return result_deque


# вводим два числа, с которыми проводим операции
NUMBER_ONE = deque('A2')
NUMBER_TWO = deque('C4F')

print(f'Вычислим сумму чисел {list(NUMBER_ONE)} и {list(NUMBER_TWO)}')
print(f'Сумма равна: {list(add(NUMBER_ONE, NUMBER_TWO))}\n')

# вводим два числа, с которыми проводим операции
NUMBER_ONE = deque('A2')
NUMBER_TWO = deque('C4F')

print(f'Вычислим произведение чисел {list(NUMBER_ONE)} и {list(NUMBER_TWO)}')
print(f'Произведение равно: {list(mul(NUMBER_ONE, NUMBER_TWO))}')
