"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

"""     ИСХОДНОЕ РЕШЕНИЕ:

############   1 VARIANT  Обычный цмкл   ##################

def loop_sum(num):
    '''Функция суммы элементов ряда 1 -0.5 0.25 -0.125 ...'''
    sum_sequence = 0
    for i in range(num):
        sum_sequence = sum_sequence + 1 / (-2) ** i
    return sum_sequence
    

############   2 VARIANT  Рекурсивная функция   ##################

def sum_sequence(num):
    '''Рекурсивная ункция вычисляет сумму членов последовательности 1 -0.5 0.25 -0.125...'''
    if num == 0:
        return 0
    return 1 / (-2) ** (num - 1) + sum_sequence(num - 1)
"""

import cProfile
import timeit

def loop_sum(num):
    '''Функция суммы элементов ряда 1 -0.5 0.25 -0.125 ...'''
    sum_sequence = 0
    for i in range(num):
        sum_sequence = sum_sequence + 1 / (-2) ** i
    return sum_sequence

def rec_sum(num):
    '''Функция вычисляет сумму членов последовательности 1 -0.5 0.25 -0.125...'''
    if num == 0:
        return 0
    return 1 / (-2) ** (num - 1) + rec_sum(num - 1)


############   3 VARIANT   #################

def memorize(func):
    def g(n, memory={}):
        r = memory.get(n)
        if r is None:
            r = func(n)
            memory[n] = r
        return r
    return g

@memorize
def f(num):
    if num < 1:
        return 0
    return 1 / (-2) ** (num - 1) + f(num - 1)


num = 200

print(timeit.timeit("loop_sum(num)", setup="from __main__ import loop_sum, num", number=1000))
print(timeit.timeit("rec_sum(num)", setup="from __main__ import rec_sum, num", number=1000))
print(timeit.timeit("f(num)", setup="from __main__ import f, num", number=1000))

def main():
    NUM = 10
    loop_sum(NUM)
    rec_sum(NUM)
    f(NUM)
    print(f'Количество элементов - {NUM}, их сумма - {loop_sum(NUM)}')
    print(f'Количество элементов - {NUM}, их сумма - {rec_sum(NUM)}')
    print(f'Количество элементов - {NUM}, их сумма - {f(NUM)}')

cProfile.run('main()')

'''
В исходных вариантах реализованы два алгоритма:
один с обычным цмклом, в другом используется рекурсивная функция.
    Модуль cProfile выдает нулевые значения по затратам времени вовсех вариантах
реализации. Это говорит о том, что все варианты отрабатывают без существенных задержек.
    Использование модуля timeit показывает выигрыш по времени в случае с обычным циклом
по сравнению с рекурсией, что уже наблюдалось в предыдущем примере.
Но если декорировать рекурсивную функцию, применяя мемоизацию, выигрыщ во времени
превосходит в разы даже вариант с обычным циклом, т.к. при рекурсии не рассчитывается
повторно значение, вычисление на предыдущем шаге. Это и дает экономию времени.
При увеличении числа итерраций преимущество декорированной функции становится более
очевидным, но здесь сказывается присущий рекурсии недостаток - переполнение стека.
'''
