"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

import timeit

# Вычисление n-го числа ряда Фибоначчи с помощью цикла while

STR_CODE = '''
fib1 = fib2 = 1
 
n = 10
 
while n > 0:
    fib1, fib2 = fib2, fib1 + fib2
    n -= 1

'''

# Рекурсивное вычисление n-го числа ряда Фибоначчи

STR_CODE_2 = '''
def fibonacci(n=10):
    if n in (1, 2):
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
'''

# Вычисление n-го числа ряда Фибоначчи с помощью цикла for

STR_CODE_3 = '''
fib1 = fib2 = 1
 
n = 10
 
if n < 2:
    quit()

for i in range(2, n):
    fib1, fib2 = fib2, fib1 + fib2
'''
print(timeit.timeit(STR_CODE, number=1000))
print(timeit.timeit(STR_CODE_2, number=1000))
print(timeit.timeit(STR_CODE_3, number=1000))


# Рекурсивный алгоритм является наиболее эффективным
# вариантом для выполнения поставленной задачи
# При помощи цикла while: 0.002848499999999976
# При помощи рекурсии: 0.00031679999999995045
# При помощи цикла for 0.0021107999999999683
