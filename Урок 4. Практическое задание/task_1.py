"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

import timeit


def naive(input_1):
    """O(2n^2)"""

    min_number_1 = 1000

    for j in range(len(input_1)):
        for i in range(0, len(input_1)):
            if input_1[i] <= min_number_1:
                min_number_1 = input_1[i]


def optimized(input_1):
    """O(n)"""
    min_number_1 = 1000
    for i in range(0, len(input_1)):
        if input_1[i] <= min_number_1:
            min_number_1 = input_1[i]


NUMBER_EXECUTIONS = 1000
INPUT = [28, -86, 44, -37, -7, -52, -19, -3, -15, -73, 28, -86, 44, -37, -7, -52, -19, -3, -15, -73]

TIME1 = timeit.timeit(f'naive({INPUT})',
                      setup='from __main__ import naive',
                      number=NUMBER_EXECUTIONS)

TIME2 = timeit.timeit(f'optimized({INPUT})',
                      setup='from __main__ import optimized',
                      number=NUMBER_EXECUTIONS)

print(f'O(n) Быстрее в  \
{round(TIME1 / TIME2, 2)} раз чем O(2n^2)'
      )
# Первый алгоритм линейной сложности и второй квадратичной
# (во второй добавлен второй цикл для сложности). Эффективней линейный алгоритм, так как в нем нет вложенного цикла.
