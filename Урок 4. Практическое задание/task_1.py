"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
from random import randint
from timeit import Timer


def matrix():
    matr = []  # Константное присвоение 1
    #a = int(input('Задайте количество строк в матрице: '))  # Константное присвоение  1
    #b = int(input('Задайте количество столбцов в матрице: '))  # Константное присвоение 1
    for el in range(100):
        c = []
        for i in range(100):
            c.append(randint(1, 40))
            print(f"{c[i]:4d}", end='')
        matr.append(c)
        print('\n')
    # Квадратичная сложность 3 операции в основном цикле, 2 во вложенном - 3n*2n=6n**2
    min_val = [min([n[en] for n in matr]) for en in range(len(matr[0]))]

    # Квадратичная сложность 2 операции в основном цикле, 1 во вложенном - 2n*n = 2n**2
    # min_val = [min(j) for j in matrix_tr]  # Линейная сложность n + 2 операции (присвоение и функия min)
    print(f'{min_val} минимальные значения по столбцам \n Максимальное среди них {max(min_val)}')
    # Общая сложность 1+1+1 + 6n**2 + 1 + 1 + 2n**2 + 2n = 8n**2 +2n +5
    # O(n**2) Сложность квадратичная


t1 = Timer("matrix()", "from __main__ import matrix")
print("Матрица ", t1.timeit(number=1000), "milliseconds")

"""
1.043 мс до корректировки при 10х10, 96.3 при 100х100
1.043 мс до корректировки при 10х10, 95.6 при 100х100 заменены циклы for на генераторы
В целом код всегда стараюсь писать с генераторами списков, если оно возможно.

"""
