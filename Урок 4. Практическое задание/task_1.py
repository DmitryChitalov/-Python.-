"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
import timeit
import random

def cycle_func():
    NUM = random.randint(0, 10000)
    NUM_1 = NUM
    EVEN = 0
    UNEVEN = 0
    while NUM != 0:
        REMAINDER = NUM % 10
        if REMAINDER % 2 == 0:
            EVEN += 1
        else:
            UNEVEN += 1
        NUM = NUM // 10

    return f'В числе {NUM_1} всего {EVEN + UNEVEN} цифр, из которых {EVEN} чётных и {UNEVEN} нечётных.'


def recur_met(num, ev=0, unev=0):
    if num == 0:
        return f'Количество четных и нечетных цифр в числе равно: {ev}, {unev}'
    else:
        a = num % 10
        if a % 2 == 0:
            ev += 1
        else:
            unev += 1
        return recur_met(num // 10, ev, unev)

def func_try():
    try:
        NUM = random.randint(0, 10000)
        recur_met(NUM)
    except ValueError:
        print('Вы ввели не число!')

print(timeit.timeit('cycle_func()', setup="from __main__ import cycle_func", number=1000))
print(timeit.timeit('func_try()', setup="from __main__ import func_try", number=1000))

''' 
ВРЕМЯ, полученное в экспериментах:
1. Случайное число в пределах 100.
0.0028783000000000003 
0.0027903999999999984

0.0027804999999999913
0.0029893999999999893

0.0028117000000000003
0.0028032999999999947

0.007022500000000001
0.012871399999999998

2. Случайное число в пределах 1000.
0.0030678999999999984
0.004215900000000002

0.0035747
0.0032908999999999994

0.0034328999999999957
0.003673799999999998

0.0031161999999999995
0.003439600000000001

Результаты получились не однозначные. При увеличении предела выбора случайного числа лучше видно разницу. 
Чаще время выполнения больше у рекурсивной функции, но случается и наоборот. В обеих функциях сложность алгоритмов
О(n). Как оптимизировать эти функции не придумала. Эффективнее все же выбирать вариант решения циклом,
так как его показатель времени чуть лучше. 
'''