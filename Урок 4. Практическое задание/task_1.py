"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
---------------------------------------------------------------------------------------------------------------------
Задание_1. В диапазоне натуральных чисел от 2 до 99 определить,
сколько из них кратны каждому из чисел в диапазоне от 2 до 9.

Подсказка: используйте вложенный цикл

Пример:
В диапазоне 2-99: 49 чисел кратны 2
В диапазоне 2-99: 33 чисел кратны 3
В диапазоне 2-99: 24 чисел кратны 4
В диапазоне 2-99: 19 чисел кратны 5
В диапазоне 2-99: 16 чисел кратны 6
В диапазоне 2-99: 14 чисел кратны 7
В диапазоне 2-99: 12 чисел кратны 8
В диапазоне 2-99: 11 чисел кратны 9
"""


from timeit import Timer


def task_1_1():
    lst_1 = list(range(2, 100))
    lst_2 = list(range(2, 10))
    for elem in lst_2:
        numb = 0
        for i in lst_1:
            if i % elem == 0:
                numb += 1
        print(f"В диапазоне 2-99: {numb} чисел кратны {elem}")


# вариант 2
def task_1_2():
    for i in range(2, 10):
        new_list = [el for el in range(2, 100) if el % i == 0]
        print(f'В диапазоне 2-99: {len(new_list)} чисел кратны {i}')


t1 = Timer("task_1_1()", "from __main__ import task_1_1")
# task_1_1 : 0.5289953999999999 milliseconds
print("task_1_1 :", t1.timeit(number=1000), "milliseconds")
print('\n \n \n')
t2 = Timer("task_1_2()", "from __main__ import task_1_2")
# task_1_2 : 0.19618209999999991 millisecond
print("task_1_2 :", t2.timeit(number=1000), "millisecond")

# Вложенный цикл в функции task_1_1 сказывается на производительности алгоритма Так же регистрация доп переменных в
# первой функции будет замедлять выполнениe алгоритма. Генератор в цикле максимально хорошо смотрится как оптимальное
# решение данной задачи т.к. Все необходимые операции и условия укладываются в конструкцию генератора,
# да и кода писать нужно порядком меньше. Генератор выигрывает у вложенных циклов примерно в 2.5 раза,
# о чем свидетельствуют показатели t1 и t2.
