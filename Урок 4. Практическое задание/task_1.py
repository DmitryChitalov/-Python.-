"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
"""
Задание_1. В диапазоне натуральных чисел от 2 до 99 определить,
сколько из них кратны каждому из чисел в диапазоне от 2 до 9.
Подсказка: используйте вложенный цикл
Пример:
В диапазоне 2-99: 49 чисел кратны 2
В диапазоне 2-99: 33 чисел кратны 3
В диапазоне 2-99: 24 чисел кратны 4
В диапазоне 2-99: 19 чисел кратны 5
В диапазоне 2-99: 16 чисел кратны 6
В диапазоне 2-99: 14 чисел кратны 7
В диапазоне 2-99: 12 чисел кратны 8
В диапазоне 2-99: 11 чисел кратны 9
"""

import cProfile


def numbers():
    LIST_OF_NUMBERS = []

    for i in range(10000):
        if i != 0 and i != 1:
            LIST_OF_NUMBERS.append(i)
    for i in range(1000):
        COUNTER = 0
        if i != 0 and i != 1:
            for item in LIST_OF_NUMBERS:
                if item % i == 0:
                    COUNTER += 1
            # print(f'В диапазоне 2-99: {COUNTER} чисел кратны {i}')


cProfile.run('numbers()')

"""
Вызовы производил на довольно больших числах, иначе результаты замеров практически равны нулю.
Результаты замеров: 
    10002 function calls in 1.290 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    1.289    1.289 <string>:1(<module>)
        1    1.287    1.287    1.289    1.289 training.py:19(numbers)
        1    0.000    0.000    1.290    1.290 {built-in method builtins.exec}
     9998    0.002    0.000    0.002    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

Из результатов видно, что производится 9998 запусков функции append(), но основная задержка выходит, вероятно, из-за 
вложенных циклов. Я решил попробывать поменять генерацию списка через append() на генерацию через генератор.

def numbers():
    LIST_OF_NUMBERS = [i for i in range(10000) if i != 0 and i != 1]

    for i in range(1000):
        COUNTER = 0
        if i != 0 and i != 1:
            for item in LIST_OF_NUMBERS:
                if item % i == 0:
                    # if item % i == 0:
                    COUNTER += 1
            # print(f'В диапазоне 2-99: {COUNTER} чисел кратны {i}')

Резуьтат после изменений: 

5 function calls in 1.299 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    1.299    1.299 <string>:1(<module>)
        1    1.297    1.297    1.299    1.299 training_2.py:4(numbers)
        1    0.002    0.002    0.002    0.002 training_2.py:6(<listcomp>)
        1    0.000    0.000    1.299    1.299 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

Из результата видно, что изменения не улучшили скорость работы функции, но даже наоборот, ухудшили результат на сотые 
доли секунды. Хотя, количество вызовов функции заметно снизилось. Каких-либо вариантов оптимизации данной функции 
в части вложенных циклов я не нашел.

Отсюда можно сделать вывод, что первоначальный вариант кода является самым оптимальным для данного этапа моего уровня, 
как программиста.
"""


