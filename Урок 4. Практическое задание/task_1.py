"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
import timeit

"""
Задание_2. Во втором массиве сохранить индексы четных элементов первого массива.
Например, если дан массив со значениями 8, 3, 15, 6, 4, 2, то во второй массив
надо заполнить значениями 1, 4, 5, 6 (или 0, 3, 4, 5 - если индексация начинается с нуля),
т.к. именно в этих позициях первого массива стоят четные числа.
"""

STR_CODE_1_COMPREHENSION = """
LIST_1 = [8, 3, 15, 6, 4, 2, 10, 21, 12, 1345, 13421346, 123, 123]
LIST_2 = []
RESULT = [LIST_2.append(i) for i, x in enumerate(LIST_1) if not x % 2]
"""

STR_CODE_1 = """
LIST_3 = [8, 3, 15, 6, 4, 2, 10, 21, 12, 1345, 13421346, 123, 123]
LIST_4 = []
for i in range(len(LIST_3)):
    if not LIST_3[i] % 2:
        LIST_4.append(i)
"""

print(f"Выполение задания 2 из урока №3 через генератор составляет: "
      f"{timeit.timeit(STR_CODE_1_COMPREHENSION, number=1000)} мс")
print(f"Выполение задания 2 из урока №3 через цикл составляет:"
      f"{timeit.timeit(STR_CODE_1, number=1000)} мс")
print("Генератор и обычный цикл работают почти одинаково")
print()

"""
2.	Посчитать четные и нечетные цифры введенного натурального числа.
Например, если введено число 34560, то у него 3 четные цифры
(4, 6 и 0) и 2 нечетные (3 и 5).
"""

STR_CODE_2_CYCLE = """
NUMB = 3456046
NUMB_EVEN = 0
NUMB_ODD = 0
NEW_NUMB = NUMB
while NEW_NUMB > 0:
    if (NEW_NUMB % 10) % 2 == 0:
        NUMB_EVEN += 1
    else:
        NUMB_ODD += 1
    NEW_NUMB = NEW_NUMB // 10
# print(f"В числе {NUMB} всего {len(str(NUMB))} цифр, "
#       f"из которых {NUMB_EVEN} чётных и {NUMB_ODD} нечетных")
"""


def recursion_nums(num, odd=0, even=0):
    """Проверка на четность и нечетность цифр в числе"""
    res_num = num % 10
    if res_num % 2 == 0:
        even += 1
    else:
        odd += 1
    num //= 10
    if num == 0:
        return f"Количество четных и нечетных цифр в числе равно: ({even}, {odd})"
    return recursion_nums(num, odd, even)


print(f"Выполение задания 2 из урока №2 через цикл составляет: "
      f"{timeit.timeit(STR_CODE_2_CYCLE, number=1000)} мс")
print(f"Выполение задания 2 из урока №2 через рекурсию составляет: "
      f"{timeit.timeit('recursion_nums(3456046)', setup='from __main__ import recursion_nums', number=1000)} мс")
print("Решение задачи через рекурсию будет затратнее по времени")
print()

STR_CODE_3 = """
NUMB = 345604789614
RESULT = ''
while NUMB > 0:
    RESULT += str(NUMB % 10)
    NUMB = NUMB // 10
# print(RESULT)
"""


def recursion_inverse(num, number=''):
    """Переворот числа через рекурсию"""
    number += str(num % 10)
    num //= 10
    if num == 0:
        return f"Перевернутое число: {number}"
    return recursion_inverse(num, number)


STR_CODE_3_NEW = """
N = 345604789614
M = 0
while N>0:
    M = N*10 + N%10
    N = N//10
"""

print(f"Выполение задания 3 из урока №2 через цикл с конкатенацией составляет: "
      f"{timeit.timeit(STR_CODE_3, number=1000)} мс")
print(f"Выполение задания 3 из урока №2 через цикл без конкатенации строк составляет: "
      f"{timeit.timeit(STR_CODE_3_NEW, number=1000)} мс")
print(f"Выполение задания 3 из урока №2 через рекурсию составляет: "
      f"{timeit.timeit('recursion_inverse(345604789614)', setup='from __main__ import recursion_inverse', number=1000)} мс")
print("В данном случае рекурсия и цикл с конкатенацией строк занимают почти одинаковое время выполнения. "
      "Так что было принято решение оптимизировать цикл, используя только математические действия\n"
      "Что в итоге ускорило работу программы.")
