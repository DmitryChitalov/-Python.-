"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

from random import randint
import timeit

"""
В качестве примера беру задачу 3 из урока 2. 
Требовалось изменить порядок цифр в ведённом числе, на обратный.
"""

# Первая реализация на рекурсиях:

def revers(enter_num, revers_num=0):
    """
    Функция принимает в качестве аргумента число, которое преобразует таким образом,
    что в новом числе цифы располагаются в обратном порядке.

    Функция вызывается рекурсивно до тех пор, пока в ведённом числе есть цифры больше 0
    :param enter_num:
    :param revers_num:
    :return:
    """
    # Условие остановки рекурсивных вызовов - введённое число стало == 0
    if enter_num == 0:
        return
    num = enter_num % 10  # получение единиц из введённого числа
    revers_num = (revers_num + num / 10) * 10  # присоединение единиц в обратном порядке
    enter_num //= 10  # убрать обработанный порядок у исходного числа
    revers(enter_num, revers_num)  # Рекурсивный вызов функции

def revers_2(enter_num):
    """
    Функция принимает в качестве аргумента число, которое преобразует таким образом,
    что в новом числе цифы располагаются в обратном порядке.

    :param enter_num:
    """
    revers_num = 0
    while enter_num != 0:
        # получение единиц из введённого числа
        num = enter_num % 10
        # присоединение единиц в обратном порядке
        revers_num = (revers_num + num / 10) * 10
        # убрать обработанный порядок у исходного числа
        enter_num //= 10
    # Вывод результата
    return revers_num

def revers_3(enter_num):
    """
    Функция принимает в качестве аргумента число, которое преобразует таким образом,
    что в новом числе цифы располагаются в обратном порядке.

    :param enter_num:
    """
    enter_num = str(enter_num)
    revers_num = enter_num[::-1]
    return revers_num

try:
    ENTER_NUM = int(input('Введите целое число: '))  # Ввод исходного числа
    print('Обратное число на рекурсиях, 10000 повторов: ',
          timeit.timeit(
              f'revers({ENTER_NUM})',
              setup='from __main__ import revers',
              number=10000))
    print('Обратное число на циклах, 10000 повторов: ',
          timeit.timeit(
              f'revers_2({ENTER_NUM})',
              setup='from __main__ import revers_2',
              number=10000))
    print('Обратное число на срезах, 10000 повторов: ',
          timeit.timeit(
              f'revers_3({ENTER_NUM})',
              setup='from __main__ import revers_3',
              number=10000))
except ValueError:
    print('Необходимо вводить число.')

"""
Введите целое число: 1234
Обратное число на рекурсиях, 10000 повторов:  0.02182890000000004
Обратное число на циклах, 10000 повторов:  0.014560199999999801
Обратное число на срезах, 10000 повторов:  0.0070453999999999795

Введите целое число: 123456789
Обратное число на рекурсиях, 10000 повторов:  0.05958060000000032
Обратное число на циклах, 10000 повторов:  0.04087279999999982
Обратное число на срезах, 10000 повторов:  0.007805199999999957

Введите целое число: 123456789123456789456123456789456123456789456123456789456123
Обратное число на рекурсиях, 10000 повторов:  0.6353027999999998
Обратное число на циклах, 10000 повторов:  0.4231689999999997
Обратное число на срезах, 10000 повторов:  0.02254109999999976

Все три функции имеют линейную сложность, но первые две T(n)=4n и T(n)=3n => O(n), 
а третья использует срез, который оценивается как O(n+k),
но так-как функции на рекурсиях и циклах имеют три арифметические операции,
их время выполнения растёт заметно быстрее, тем более время выполнения рекурсий,
которые тратят дополнительные ресурсы на рекурсивный вызов функции. 
В свою очередь срез, отрабатывает заметно быстрее из-за того, что избавлен 
от необходимости выполнять арифметические операции.

Вывод: Реализация через срез самая эффективная.
"""

"""
Второй пример - задача 8 к уроку 3.
Необходимо в матрице добавлять столбец в который будут попадать суммы чисел в строках.
"""

def row_sum(column_count, row_count):
    my_list = []
    for J in range(row_count):
        my_list.append([])
        for I in range(column_count):
            my_list[J].append(randint(0, 10))
        my_list[J].append(sum(my_list[J]))
    return

def row_sum_2(column_count, row_count):
    my_list = [[randint(0, 10) for I in range(column_count)] for J in range(row_count)]

    for itm in my_list:
        itm.append(sum(itm))
    return


print('Матрица 5х5, на циклах, 1000 повторов: ',
          timeit.timeit(
              'row_sum(5, 5)',
              setup='from __main__ import row_sum',
              number=1000))
print('Матрица 5х5, на генераторах, 1000 повторов: ',
          timeit.timeit(
              'row_sum_2(5, 5)',
              setup='from __main__ import row_sum_2',
              number=1000))
print('Матрица 50х50, на циклах, 1000 повторов: ',
          timeit.timeit(
              'row_sum(50, 50)',
              setup='from __main__ import row_sum',
              number=1000))
print('Матрица 50х50, на генераторах, 1000 повторов: ',
          timeit.timeit(
              'row_sum_2(50, 50)',
              setup='from __main__ import row_sum_2',
              number=1000))
print('Матрица 100х100, на циклах, 1000 повторов: ',
          timeit.timeit(
              'row_sum(100, 100)',
              setup='from __main__ import row_sum',
              number=1000))
print('Матрица 100х100, на генераторах, 1000 повторов: ',
          timeit.timeit(
              'row_sum_2(100, 100)',
              setup='from __main__ import row_sum_2',
              number=1000))

"""
Результаты замеров:
Матрица 5х5, на циклах, 1000 повторов:  0.1232423
Матрица 5х5, на генераторах, 1000 повторов:  0.10605109999999995
Матрица 50х50, на циклах, 1000 повторов:  9.342552999999999
Матрица 50х50, на генераторах, 1000 повторов:  8.769037699999998
Матрица 100х100, на циклах, 1000 повторов:  35.4869489
Матрица 100х100, на генераторах, 1000 повторов:  33.82511000000001

Обе реализации имеют квадратичную сложность O(n2), но за счет более
оптимизированных - генераторов списков, вторая функция стабильно выполняется
быстрее. Наименьшая разница при вводе матрицы 100х100 и тысяче повторов,
в данном случае реализация на циклах отстаёт всего на 4,68%, но
для малых матриц 5х5 генераторы выигрывают у циклов до 14% по времени исполнения.
"""
