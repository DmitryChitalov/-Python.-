"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
import random
import timeit

m = 0
num = 0
array = [random.randint(0, 10) for el in range(10)]  # 1 сложность зависит от кол-ва элементов в range (n)


def func_1():
    global m, num
    # print(array) - Чтобы не выводились результаты по 1000 раз при проверке времени
    m = 0
    num = 0  # 2 два присваивания - константа (2)
    for i in array:  # посчитать количество каждого элемента в массиве - получается n*n (каждый элемент "проходится" по массиву и считается)? (n2)
        count = array.count(i)
        if count > m:
            m = count  # 2 присваивания - 2? (2)
            num = i
    # return (f'Чаще всего встречается число {num}, оно появилось в массиве {m} раз(а)')


# T(n) = n + 2 + n2 + 2 = n2 + n + 4
# O(n2)

func_1()

# Решение через ф-ю max (Мое):

elem = 0  # константа (1)


def func_2():
    new_array = []  # константа (1)
    for el in array:  # посчитать количество каждого элемента в массиве - получается n*n (каждый элемент "проходится" по массиву и считается)? (n2)
        count2 = array.count(el)
        new_array.append(count2)  # константа (1)
    # print(new_array)
    max_2 = max(new_array)  # выбор наибольшего элемента в массиве - перебор всех вариантов - n? (n)
    elem = array[new_array.index(max_2)]  # константа (1)
    # return (f'Чаще всего встречается число {elem}, оно появилось в массиве {max_2} раз(а)')


func_2()


# T(n) = 1 + 1 + n2 + 1 + n + 1 = n2 + n + 4
# O(n2)


# Решение через ф-ю max (Преподаватель):

def func_3():
    # print(array)
    numb = max(array, key=array.count)  # подсчет количества - (n*n), включение в массив - константа (1), максимум - n
    # return (f"Чаще всего встречается число {numb}, оно появилось в массиве {array.count(numb)} раз(а)")


func_3()

# T(n) = n2 + n + 1
# O(n2)
###

print(timeit.timeit("func_1()", setup="from __main__ import func_1", number=1000))
print(timeit.timeit("func_2()", setup="from __main__ import func_2", number=1000))
print(timeit.timeit("func_3()", setup="from __main__ import func_3", number=1000))

"""
Результаты при входном массиве из 20 элементов:
0.010300291999999996
0.011873128999999996 - Самый долгий 
0.007056251999999999 - Самый быстрый результат 

Результаты при входном массиве из 100 элементов:
0.170216384 - Самый долгий
0.16327756200000001
0.12619019999999997 - Самый быстрый

Результаты при входном массиве из 3 элементов:
0.0012272480000000002 - Самый быстрый
0.0022005629999999957 - Самый долгий
0.0017927449999999984

Результаты при входном массиве из 1000 элементов:
13.721137027000001 
14.225485828999998 - Самый долгий
13.515754824999998 - Самый быстрый

Итог:
В основном самый долгий результат дает второй вариант. Это связано с тем, что в рамках функции func_2 формируется 
новый массив чисел из количества включений числа изначального массива, т.е. для каждого числа изначального массива 
считается, сколько раз оно включается в массив (функция "пробегает" по всему массиву), и это число включается в новый 
массив. Далее определяется максимум нового массива, т.е. снова анализируется весь новый массив. 

Третий вариант, как правило, самый быстрый, поскольку в нем сразу определяется максимум из количества включений числа 
в массив.  

"""
