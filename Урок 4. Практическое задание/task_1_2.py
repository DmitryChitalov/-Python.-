"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

#      ИСХОДНОЕ РЕШЕНИЕ:
#
# #######  1 VARIANT  #######
#
# def ev_odd_loop(num):
#     '''Функция с циклом'''
#     even = 0
#     odd = 0
#     while num != 0:
#         rest_num = num % 10
#         num = num // 10
#         if rest_num % 2 == 0:
#             even += 1
#         else:
#             odd += 1
#     return even, odd
#
# NUM = int(input('Enter some natural number: '))
# print(f'Количество четных и нечетных цифр в числе равно: {ev_odd_loop(NUM)}')
#
# #######  2 VARIANT  #######
#
# def odd(num):
#     '''Рекурсивная функция подсчета нечетных цифр числа'''
#     if num == 0:
#         return 0
#     return num % 10 % 2 + odd(num // 10)
#
# NUM = input('Enter some natural number: ')
# ODD = odd(int(NUM))
# print(f'Количество четных и нечетных цифр в числе равно: ({len(NUM) - ODD}, {ODD})')
#
# #######  3 VARIANT  #######
#
# def even_odd(num, even=0, odd=0):
#     '''Рекурсивная функция подсчета четных и нечетных цифр числа'''
#     if num == 0:
#         return (even, odd)
#     if num % 10 % 2 == 0:
#         even += 1
#     else:
#         odd += 1
#     num //= 10
#     return even_odd(num, even, odd)
#
#
# NUM = int(input('Enter some natural number: '))
# print(f'Количество четных и нечетных цифр в числе равно: {even_odd(NUM)}')


import cProfile
import timeit

def loop_even_odd(num):
    '''Функция с циклом'''
    even = 0
    odd = 0
    while num != 0:
        rest_num = num % 10
        num = num // 10
        if rest_num % 2 == 0:
            even += 1
        else:
            odd += 1
    return even, odd

def rec_odd(num):
    '''Рекурсивная функция подсчета нечетных цифр числа'''
    if num == 0:
        return 0
    return num % 10 % 2 + rec_odd(num // 10)

def rec_even_odd(num, even=0, odd=0):
    '''Рекурсивная функция подсчета четных и нечетных цифр числа'''
    if num == 0:
        return (even, odd)
    if num % 10 % 2 == 0:
        even += 1
    else:
        odd += 1
    num //= 10
    return rec_even_odd(num, even, odd)

def main():
    loop_even_odd(1111100000)
    rec_odd(1111100000)
    rec_even_odd(1111100000)

print(timeit.timeit("loop_even_odd(1111100000)", setup="from __main__ import loop_even_odd", number=1000))
print(timeit.timeit("rec_odd(1111100000)", setup="from __main__ import rec_odd", number=1000))
print(timeit.timeit("rec_even_odd(1111100000)", setup="from __main__ import rec_even_odd", number=1000))


cProfile.run('main()')

'''
В исходных вариантах реализованы три алгоритма:
один с цмклом, в двух других используется ркеурсия.
Из исходных вариантов реализации так же удалены функции print(), чтобы протестировать только
сами алгоритмы.
    Модуль cProfile выдает нулевые значения по затратам времени во всех вариантах
реализации. Это говорит о том, что все варианты отрабатывают без существенных задержек.
    Использование модуля timeit показывает временнОе преимущество варианта с обычным циклом,
т.к. рекурсия предполагает запись в стек и обращение к нему.
Второй вариант рекурсии более затратный по времени, потому что предусматривает при каждом
вызове функции увеличение одной из переменных в зависимости от условия.
Второй вариант рекурсии очень близок к варианту с обычным циклом, т.к. в цикле также используется
сравнение и инкремент двух переменных по условию, что нивелирует преимущество перед рекурсией.
'''
