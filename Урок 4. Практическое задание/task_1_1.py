import timeit
import random


def ascii_table():
    num_letter = random.randint(1, 26)
    letter = chr(96 + num_letter)
    return f'Введенному номеру соответствует буква: {letter}'


def dict():
    alphabet = {'1': 'a', '2': 'b', '3': 'c', '4': 'd', '5': 'e', '6': 'f', '7': 'g', '8': 'h', '9': 'i', '10': 'j',
                '11': 'k', '12': 'l', '13': 'm', '14': 'n', '15': 'o', '16': 'p', '17': 'q', '18': 'r', '19': 's',
                '20': 't', '21': 'u', '22': 'v', '23': 'w', '24': 'x', '25': 'y', '26': 'z'
                }
    num_letter = str(random.randint(1, 26))
    return f'Введенному номеру соответствует буква: {alphabet[num_letter]}'


def dict_2():
    alphabet = {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f', 7: 'g', 8: 'h', 9: 'i', 10: 'j',
                11: 'k', 12: 'l', 13: 'm', 14: 'n', 15: 'o', 16: 'p', 17: 'q', 18: 'r', 19: 's', 20: 't',
                21: 'u', 22: 'v', 23: 'w', 24: 'x', 25: 'y', 26: 'z'
                }
    num_letter = random.randint(1, 26)
    return f'Введенному номеру соответствует буква: {alphabet[num_letter]}'


print(timeit.timeit('ascii_table()', setup="from __main__ import ascii_table", number=1000))
print(timeit.timeit('dict()', setup="from __main__ import dict", number=1000))
print(timeit.timeit('dict_2()', setup="from __main__ import dict_2", number=1000))

'''
Результаты эксперимента:

0.0021081999999999976 - вариант с ascii-таблицей
0.0036600999999999995 - вариант со словарем, где ключи даны в строковом типе данных
0.0027930999999999997 - вариант со словарем, где ключи имеют числовой тип данных

0.0024645000000000014
0.003062300000000004
0.0027507999999999977

0.0017281999999999992
0.0030501
0.0027176999999999965

По нашему эксперименту видно, что вариант с ascii-таблицей выигрывает в быстроте выдачи результата. Вариант со словарем, 
где ключи представлены строками, оказался наиболее медленным, поэтому я его попыталась оптимизировать, преобразовав 
ключи в числовой тип данных. Это действительно чуть уменьшило время. 

Вариант с обращением к словарю оказался дольше, чем встроенная функция chr(). 

'''
