"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
import timeit
import random


# Мое решение:

def my_func():
    #num = int(input('Введите номер числа: '))
    num = 1000
    k = num * 10
    array_sn = [1, 2]
    b = 0
    for i in range(k):
        for j in range(2, i):
            if i % j == 0:
                b = 0
                break
            else:
                b = i
        if b > 0:
            array_sn.append(b)
    #print(array_sn)
    #print(f'Простое число под номером {num} - это {array_sn[num - 1]}')


my_func()


# print(f'Простое число под номером {num} - это {array_sn[num - 1]}')

# Решето:

def sieve():
    #num = int(input('Введите номер числа: '))
    num = 1000
    k = num * 10
    new_list = list(range(k))
    for i in new_list:
        if i > 1:
            for j in range(i + i, len(new_list), i):
                new_list[j] = 0
    new_list_2 = [el for el in new_list if el != 0]
    #print(new_list_2)
    #print(f'Простое число под номером {num} - это {new_list_2[num - 1]}')


sieve()
###

print(timeit.timeit("my_func()", setup="from __main__ import my_func", number=1000))
print(timeit.timeit("sieve()", setup="from __main__ import sieve", number=1000))

"""
Результаты:
- от 10:
0.097239974
0.024012090999999985

- от 100:
4.522999841
0.2014237200000002

- от 1000 (комп завис :):
414.914652732
2.1219693259999985

Вывод: чем больше вводное число (номер простого числа), тем значительнее проигрывает моя функция алгоритму Решето. 
Я думаю, что это связано с тем, что в моей версии строится огромный массив чисел, каждое из которого каждый раз по циклу 
проверятся на деление на предыдущие числа, также из этого списка, и строится новый список. 
В случае Решета сразу один раз строится большой массив, из которого в дальнейшем убираются ненужные элементы - 
нет постоянного "прохода" по большому массиву данных.
"""
