"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
import timeit
from math import sqrt
"""
самую высокую скорость обработки имеет алгоритм "решето Эратосфена".
Это обусловлено тем,что решето не предусматривает поэлементную проверку
делимости.
Остальные же два варианта основаны на поэлементной проверке,что увеличивает
их сложность:
с использованием алгоритма "решето Эратосфена" :  O(nlog(logn))
без использования алгоритма "решето Эратосфена" : O(n^2)
Разница во времени на малых значениях N между prime_2 и prime_eratosphen незначительна,
но с увеличением числа N
разница становится существенной. Первый же вариант сильно проигровает в скорости.
"""

# первый вариант поиска путем перебора делителей

def prime(n):
    prime_lst = []
    for el in range(2, n):
        for i in range(2, el):  # перебираем делители
            if el % i == 0:  # если делитель найден, то число составное и выходим из цикла
                break
        else:
            prime_lst.append(el)
    return prime_lst

# второй вариант алгоритма тоже основан на переборе делителей.
# так как нужно перебрать только те числа, не превосходящие корня искомого,
# то можем немного оптимизировать данный алгоритм

def prime_2(n):
    prime_lst = []
    for el in range(2, n+1):
        for i in prime_lst:
            if i > int((sqrt(el)) + 1):
                prime_lst.append(el)
                break
            if el % i == 0:
                break
        else:
            prime_lst.append(el)
    return prime_lst


# решето Эратосфена

def prime_eratosphen(n):
    a = list(range(n+1))
    a[1] = 0
    prime_lst = []

    i = 2
    while i <= n:
        if a[i] != 0:
            prime_lst.append(a[i])
            for j in range(i, n+1, i):
                a[j] = 0
        i += 1
    return prime_lst

print(f'Время работы без использования алгоритма "решето Эратосфена" методом перебора делителей :'
      f'{timeit.timeit("prime(1000)", setup="from __main__ import prime", number=1000)}')
print(f'Время работы без использования алгоритма "решето Эратосфена" оптимизированной функции :'
      f'{timeit.timeit("prime_2(1000)", setup="from __main__ import prime_2", number=1000)}')
print(f'Время работы используя алгоритм "решето Эратосфена" :'
      f'{timeit.timeit("prime_eratosphen(1000)", setup="from __main__ import prime_eratosphen", number=1000)}')
