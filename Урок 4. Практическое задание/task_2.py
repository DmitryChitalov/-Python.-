"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""


import random
import timeit


def simpl_num(num, counter=2):
    """Реализация без решета"""
    nums = []
    while True:
        tmp = 1
        for i in range(2, counter):
            if counter % i == 0:
                tmp += 1
        if tmp <= 1:
            nums.append(counter)
        if len(nums) == num:
            break
        counter += 1
    return nums


"""Решето Эратосфена"""

TMP = '''
n = 100
a = [0] * int((n * n / 2))
for i in range(int(n * n / 2)):
    a[i] = i
a[1] = 0
def sieve(n, a, m=2):
    """Функция по вычислению"""
    if a[m] ** 2 <= (n * n / 2) and a[m] != 0:
        for i in range(m**2, int(n * n / 2), m):
            a[i] = 0
    if len([i for i in a if i != 0 and i < (n * n / 2)]) <= n:
        sieve(n, a, m + 1)
    return [i for i in a if i != 0][:n]
'''
print(
    timeit.timeit(
        "simpl_num(100)",
        setup="from __main__ import simpl_num, random",
        number=1000))

print(timeit.timeit(TMP, number=1000))

# На порядке 10 получаем перебор - 0.0358215 решето - 0.0027937
# На порядке 100 получаем перебор - 8.3259998 решето - 0.2539723
# На порядке 1000 получаем перебор - 2393.9035122 решето - 31.246185999999852
# Вывод, наглядно можно понять, что алгоритны с отсеиванием выглядят гораздо эффективнее
# нежели прямой подход к решению задачи перебором всех элементов.
# При решении задач с небольшими данными сушественной разницы нет, но если данных много,
# то нужно стараться максимально сократить время решения, это выигрывает
# массу времени
