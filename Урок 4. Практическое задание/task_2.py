"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

# импортируем модуль math для использования корня
import math
# импортируем модуль для анализа времени выполнения
from timeit import Timer


# Алгоритм 1
def without_era(source_number):
    # здесь будем задавать порядковый номер числа для вычислений
    number = source_number

    # число является простым если оно больше единицы,
    # а также делится только само на себя и на единицу

    # создадим функцию для определения простоты числа
    def is_simple(num):
        # i - делитель, который будем увеличивать в цикле
        i = 2
        # будем производить перебор от 2 до корня из num
        lim = int(math.sqrt(num))
        while i <= lim:
            # если число нацело делится на текущий делитель, то оно составное
            if num % i == 0:
                return False
            i += 1
        # т.к. число не определилось как составное, значит простое
        return True

    # введем переменную итерируемую переменную i,
    # которой сразу зададим значение 2 (первое простое число)
    i = 2
    # введем счетчик простых чисел
    counter = 0
    # создадим цикл от i до искомого порядкового номера
    while True:
        # проверяем число на простоту и увеличиваем счетчик
        if is_simple(i):
            counter += 1
        # если находим простое число требуемого порядка,
        # то останавливаем цикл
        if counter == number:
            # вывод закомментируем
            # print(i)
            break
        i += 1


# Алгоритм 2. «Решето Эратосфена»

# wiki:
# Для нахождения всех простых чисел не больше заданного числа n,
# следуя методу Эратосфена, нужно выполнить следующие шаги:
# 1. Выписать подряд все целые числа от двух до n (2, 3, 4, …, n).
# 2. Пусть переменная p изначально равна двум — первому простому числу.
# 3. Зачеркнуть в списке числа от 2p до n считая шагами по p (это будут числа кратные p: 2p, 3p, 4p, …).
# 4. Найти первое незачёркнутое число в списке, большее чем p, и присвоить значению переменной p это число.
# 5. Повторять шаги 3 и 4, пока возможно.

def with_era(source_number):
    # здесь будем задавать порядковый номер числа для вычислений
    number = source_number

    # шаг 1
    source_list = [i for i in range(2, number+1)]

    # шаг 2
    p = 2
    # шаги 3, 4
    while (p * p) <= number:
        for i in range(p * 2, number+1, p):
            if source_list.count(i) >= 1:
                source_list.remove(i)
        p += 1
    # вывод закомментируем
    # print(source_list)


T1 = Timer("without_era(10)", "from __main__ import without_era")
print(f'Время выполнения Алгоритма 1 (10): {T1.timeit(number=1000)}')
T2 = Timer("without_era(100)", "from __main__ import without_era")
print(f'Время выполнения Алгоритма 1 (100): {T2.timeit(number=1000)}')
T3 = Timer("without_era(1000)", "from __main__ import without_era")
print(f'Время выполнения Алгоритма 1 (1000): {T3.timeit(number=1000)}')

T4 = Timer("with_era(10)", "from __main__ import with_era")
print(f'Время выполнения Алгоритма 2 (10): {T4.timeit(number=1000)}')
T5 = Timer("with_era(100)", "from __main__ import with_era")
print(f'Время выполнения Алгоритма 2 (100): {T5.timeit(number=1000)}')
T6 = Timer("with_era(1000)", "from __main__ import with_era")
print(f'Время выполнения Алгоритма 2 (1000): {T6.timeit(number=1000)}')

# К сожалению, не понял как преобразовать алгоритм Эратосфена
# под задачу поиска конкретного порядкового простого числа.
# Либо изначально понял задачу некорректно.

# Вывод по выполнению:
# Алгоритм Эратосфена позволяет производить вычисления быстрее при меньшем объеме данных,
# т.к. при вызовах 10 и 100 выполнился быстрее, чем при вызове 1000.
