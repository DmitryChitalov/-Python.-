"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
import timeit

#Без использования «Решета Эратосфена»:
def no_erastofen(n):
    arr = []

    while n > 1:
        a = 0
        for i in range(2,n):
            if n%i == 0:
                a += 1
        if a == 0:
            arr.append(n)
        n -=1
    arr.sort()
  #  print(f"{arr}")


#Используя алгоритм «Решето Эратосфена»:
def erastofen(n):
    a = [0] * n  # создание массива с n количеством элементов
    for i in range(n):  # заполнение массива ...
        a[i] = i  # значениями от 0 до n-1

    # вторым элементом является единица, которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0

    m = 2  # замена на 0 начинается с 3-го элемента (первые два уже нули)
    while m < n:  # перебор всех элементов до заданного числа
        if a[m] != 0:  # если он не равен нулю, то
            j = m * 2  # увеличить в два раза (текущий элемент простое число)
            while j < n:
                a[j] = 0  # заменить на 0
                j = j + m  # перейти в позицию на m больше
        m += 1

    # вывод простых чисел на экран (может быть реализован как угодно)
    b = []
    for i in a:
        if a[i] != 0:
            b.append(a[i])

    del a
 #   print(b)

n = 10

print(timeit.timeit("no_erastofen(n)", setup="from __main__ import no_erastofen,n", number=1000))
print(timeit.timeit("erastofen(n)", setup="from __main__ import erastofen,n", number=1000))

# Для n=10
# no_erastofen(n):  0.007529190996137913
# erastofen:        0.004313812001782935

# Для n=100
# no_erastofen(n):  0.35956965700461296
# erastofen:        0.03751505899708718

# Для n=1000
# no_erastofen(n):  32.480141747000744
# erastofen:        0.4052166510009556

# Вывод: проведя замеры времени выполнения алгоритмов можем видеть,
# что при исходных данных порядка 1000 скорость выполнения алгоритма
# "Без использования «Решета Эратосфена»" ~ в 100 раз ниже, чем алгоритма
# «Решето Эратосфена» ввиду наличия у первого лишних повторяющися операций,
# не смотря на то, что предположительная сложность одинаковая O(n2)

