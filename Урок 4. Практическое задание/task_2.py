"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»
Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
from timeit import timeit


def not_eratosthenes(n):  # Без использования «Решета Эратосфена»
    k = 1
    i = 2
    while k <= n:
        a = 1
        h = True
        while a <= i:
            if i % a == 0 and a != 1 and a != i:
                h = False
                break
            a += 1
        if h:
            if k == n:
                break
            k += 1
        i += 1
    return i


def eratosthenes(n):  # алгоритм «Решето Эратосфена»
    arr = [i for i in range(n)]
    arr[1] = 0
    p = 2
    while p < n:
        if arr[p] != 0:
            j = p * 2
            while j < n:
                arr[j] = 0
                j += p
        p += 1

    return [i for i in arr if arr[i] != 0]


numbers = [10, 100, 1000]
for i in numbers:
    print(
        f'Без использования «Решета Эратосфена» для {i}: '
        f'{timeit("not_eratosthenes(i)", setup="from __main__ import not_eratosthenes, i", number=100)}')
    print(
        f'C алгоритмом «Решето Эратосфена» для {i}: '
        f'{timeit("eratosthenes(i)", setup="from __main__ import eratosthenes, i", number=100)}')

'''
Для малых чисел реализация поиска через циклы с квадратичной сложностью
сопостовима с реализацией поиска используя алгоритм "решета Эратосфена".
При поиске простых чисел до 1000 без алгоритма "решета Эратосфена" уже не
обойтись. Без использования «Решета Эратосфена» для 1000: 56.69 сек;
с алгоритмом «Решето Эратосфена» для 1000: 0.070 сек. И имеет экспоненциальную 
временную сложность O(n*log log n).
'''
