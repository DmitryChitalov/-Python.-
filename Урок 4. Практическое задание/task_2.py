"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

"""
Мной были реализованы два алгоритма  первый без использования
«Решета Эратосфена» второй с использованием.
результаты измерения времени:
с без решета число 10: 0.0008169000000000093
с решетом число 10: 0.0007739999999999969
с без решета число 100: 0.005479200000000017
с решетом число 100: 0.013083599999999973
с без решета число 1000: 0.17634960000000005
с решетом число 1000: 0.12242540000000002
с без решета число 9000: 4.1301096
с решетом число 9000: 1.1918857999999997
При анализе времени работы функций можно сделать следующие выводы:
первый алгоритм эфективен для поиска значений i-го простова числа 
в небольших диапазонах и эфективность теряеться при увеличении числа
для поиска, второй алгоритм эфективен для поиска больших чисел i.
"""
from pip._vendor.msgpack.fallback import xrange
import timeit


def i_number_1(itm):
	if itm <= 9591:
		n = 100000
	else:
		n = 1000000
	lst = [2]
	for i in xrange(3, n + 1, 2):
		if (i > 10) and (i % 10 == 5):
			continue
		for j in lst:
			if j * j - 1 > i:
				lst.append(i)
				if len(lst) == itm:
					return lst[itm - 1]
				break
			if (i % j == 0):
				break
		else:
			lst.append(i)
			if len(lst) == itm:
				return lst[itm -1]
	return lst[itm -1]


def i_number_2(itm):
	if itm <= 4:
		n = 10
	elif itm <= 25:
		n = 100
	elif itm <= 168:
		n = 1000
	elif itm <= 1229:
		n = 10000
	elif itm <= 9592:
		n = 100000
	else:
		n = 1000000
	a = [itm for itm in range(n + 1)]
	a[1] = 0
	lst = []

	i = 2
	while i <= n:
		if a[i] != 0:
			lst.append(a[i])
			for j in xrange(i, n + 1, i):
				a[j] = 0
		i += 1
	return lst[itm - 1]


func_1 = timeit.timeit(
    "i_number_1(9000)",
    setup="from __main__ import i_number_1",
    number=1000)
func_2 = timeit.timeit(
    "i_number_2(9000)",
    setup="from __main__ import i_number_2",
    number=1000)

print(func_1)
print(func_2)
