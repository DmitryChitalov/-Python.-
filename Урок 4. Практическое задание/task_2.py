"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
import timeit


def func1():
    q = 0
    stop_count = 100
    t = 0
    i = 0
    while q != stop_count:  # пока чисел не 100 продолжаем цикл
        i += 1
        if t == 2:  # если у числа 2 делителя то оно простое
            q += 1
            if q == stop_count:  # если чисел набралось заданное кол-во то закончили
                return y
        t = 0
        for y in range(1, i + 1):  # перебираем делители
            if i % y == 0 and i >= y:
                t += 1


print(f'сотое натуральное число = {func1()}')
print(timeit.timeit("func1()", setup="from __main__ import func1", number=100))


def func2():
    x = []
    start_i = 2
    stop_i = 3
    count_div = 0
    start_y = start_i
    stop_y = stop_i
    all_count = 100
    while all_count != len(
            x):  # цикл с условием , проверяет , что кол-во чисел в списке = заданному кол-ву искомых чисел
        for i in range(start_i, stop_i):  # перебирает делимые числа
            for y in range(start_y, stop_y):  # перебирает делители
                if y <= i and i % y == 0:  # условия при которых число является простым
                    count_div += 1  # считает сколько раз число делится без остатка
            if count_div == 1:  # если  число делится без остатка только один раз . оно простое , если больше то нет
                x.append(i)  # добавляем число в список
            count_div = 0  # обнуляем счетчик делений
            start_i = stop_i  # индекс последней цифры предыдушего цикла = индекс первой цифры следующего
            stop_i += 1  # увеличиваем диапазон поиска простых чисел
            stop_y += 1  # увеличиваем диапазон поиска простых чисел
    return x[-1]  # возвращаем последнее число списка


print(f'сотое натуральное число = {func2()}')
print(timeit.timeit("func2()", setup="from __main__ import func2", number=100))


def func3():
    score = 0
    x_source = [x for x in range(2, 543)] #генерируем список чисел , 545 это индекс сотого простого числа
    x_result = []

    for i in x_source:
        for y in x_source:
            #if i < y: continue
            if i % y == 0 and i >= y: # условия при которых число простое
                score += 1            # считаем кол-во делений
        if score == 1:                # если деление одно то число простое
            x_result.append(i)        # записываем число в список
        score = 0
    return x_result[-1]               # искомое число последнее в списке


print(f'сотое натуральное число = {func3()}')
print(timeit.timeit("func3()", setup="from __main__ import func3", number=100))

# Самый быстрый вариант это поиск n-го простого числа без использования списков.
# Второй по времени выполнения это поиск n-го числа c использованием массива.
# Самый медленный вариант с выборкой простых чисел в список из предварительно сгенерированного списка.
# Чем больше операций со списками , тем дольше время выполнения.

