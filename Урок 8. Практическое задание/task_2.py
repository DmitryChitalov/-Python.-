"""
Закодируйте любую строку из трех слов по алгоритму Хаффмана.

Пример:
строка для кодирования
s = "beep boop beer!"

Результат:
00 11 11 101 010 00 011 011 101 010 00 11 11 1000 1001
"""

from Tree import Haffman


def get_code_string(string):
    """
    :param string: Исходная строка, которую нужно закодировать
    :return: Возвращает объект класса Haffman
    """
    tree = Haffman()
    coded = tree.encode(string)
    print(f'Base string = {string}')    # Исходная строка
    print()
    print(f'Frequency data = {tree.primary_data}')  # Исходная последовательность частот символов
    print(f'Sorted data = {tree.sorted_data}')  # Отсортированная последовательность частот символов
    print()
    print(f'coded -> {string} = {coded}')   # Закодированная строка
    print(f'decoded -> {coded} = {tree.decode(coded)}')     # Декодированная строка
    print()
    print(f'code table = {tree.code_table}')    # Таблица соответствия
    print()
    print('Tree')
    tree.show_tree(data_only=True)  # Показывает объект класса Haffman
    return tree


get_code_string("beep boop beer!")
"""
Base string = beep boop beer!

Frequency data = Counter({'e': 4, 'b': 3, 'p': 2, ' ': 2, 'o': 2, 'r': 1, '!': 1})
Sorted data = [['!', 1], ['r', 1], ['o', 2], [' ', 2], ['p', 2], ['b', 3], ['e', 4]]

coded -> beep boop beer! = 00 11 11 011 010 00 101 101 011 010 00 11 11 1001 1000 
decoded -> 00 11 11 011 010 00 101 101 011 010 00 11 11 1001 1000  = beep boop beer!

code table = {'b': '00', 'e': '11', 'p': '011', ' ': '010', 'o': '101', 'r': '1001', '!': '1000'}

Tree
15     
7     8     
b     4     4     e     
*     *           p     2     o     *     *     
*     *     *     *     *     *     *     *     !     r     *     *     *     *     *     *     

Есть отличия от исходного примера, однако ошибки нету, поскольку способ кодировки зависит от того 
как отсортирован исходный массив
В исходной задаче отсортированный массив выглядит:
r 1 , ! 1 , p 2 , o 2 , ' ' 2, b 3 , e 4
Вместо полученного:
[['!', 1], ['r', 1], ['o', 2], [' ', 2], ['p', 2], ['b', 3], ['e', 4]]

Оба массива отсортированны, но последовательность символов отличается что влияет на конечный результат
После обработки таблица соответствия в исходном примере выглядит так:
b = 00 e = 11 p = 101 ' ' = 011 o = 010 r = 1000 ! = 1001

Сравнивая отсортированные частоты можно установить соответсвие между символами
Например
Исходный: ! = 1001 r = 1000
Полученный: ! = 1000 r 1001
"""

"""
Данный метод можно использовать для кодированной передачи, если задать базовую таблицу соответствия.
При условии что строка уже имеется у отправителя и получателя
Например строка 'abcdefghijklmnopqrstuvwxyz ,!.:' Имеет 31 символ и => количество 
различных способов составления таблицы N = 31! если учеть что при тех же размерах, есть повторяющиеся элементы
количество вариантов составления таблицы многокрано возрастает
Не имея представления о базовой строке: длине , последовательности, используемых символах и их частотах
Расшифровка займет значительное время 
"""
base_string = 'abcdefghijklmnopqrstuvwxyz ,!.:'
test = get_code_string(base_string)     # Получение объекта класса Haffman
code_string = test.encode('hello world!', use_code_table=True)  # Кодируем строку при помощи заданной таблицы
base = Haffman(code_table=test.code_table)  # Задаем таблицу другому компьютеру.
decode_string = base.decode(code_string)    # Декодируем строку на другом компьютере
print(decode_string)

