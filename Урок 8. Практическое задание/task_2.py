"""
Закодируйте любую строку из трех слов по алгоритму Хаффмана.

Пример:
строка для кодирования
s = "beep boop beer!"

Результат:
00 11 11 101 010 00 011 011 101 010 00 11 11 1000 1001
"""

# импортируем модули для использования счетчика
# и очереди с приоритетами
import heapq
from collections import Counter


class Node:
    """
    Класс для узла дерева, имеет потомков
    """
    def __init__(self, left=None, right=None):
        # инициализируем узел, с потомками или без
        self.left = left
        self.right = right

    def encode(self, dic, code):
        """
        функция кодирования символа
        для прохода по узлам дерева
        """
        # если идем налево, то в словарь добавляем к значению '0'
        # если направо, то '1'
        self.left.encode(dic, code + '0')
        self.right.encode(dic, code + '1')


class Leaf:
    """
    Класс для листка дерева, не имеет потомков
    """
    def __init__(self, char):
        # инициализируем лист, который хранит в себе символ
        self.char = char

    def encode(self, dic, code):
        """
        функция кодирования символа
        """
        # в словарь по ключу символа добавляем значение 'code'
        # либо '0', если 'code' пустой
        dic[self.char] = code or '0'


def huffman(source_str):
    """
    Функция для кодирования строки алгоритмом Хаффмана
    """
    # вывод условия
    print(f'Строка для кодирования: "{source_str}"\n')

    # создаем пустую очередь с приоритетами
    heap_queue = []

    # заполняем очередь кортежами (частота, счетчик, лист)
    # частоту находим с помощью Counter
    for char, frequency in Counter(source_str).items():
        heap_queue.append((frequency, len(heap_queue), Leaf(char)))
        """
        Во время построения очереди (heapify) у нас сравниваются кортежи,
        однако сравнение происходит по уникальным элементам кортежей парами, поочередно.
        Т.е. в случае если даны два кортежа (1, объект) и (2, объект), то ошибки
        никакой не будет, мы спокойно сравним '1' и '2', этого будет достаточно.
        Однако в случае с кортежами (1, объект) и (1, объект) мы не сможем провести сравнение,
        т.к. первые элементы не уникальны, а вторые пары - объекты мы сравнить не можем.
        Из-за чего в будущем обязательно возникнет ошибка при попытке вытащить из кучи
        наименьший элемент или превращения списка в кучу.
        Именно поэтому вводим len(HEAPQ), который будет являтся уникальным элементом кортежа
        """

    # превращаем список в кучу (строим очередь с приоритетами)
    heapq.heapify(heap_queue)
    # счетчик для последующей вставки элементов
    # см. комментарий в конце листинга кода
    count = -1

    # выполняем цикл пока в куче больше одного элемента
    while len(heap_queue) > 1:
        # получаем из кучи наименьший элемент, запоминаем его частоту и узел(лист)
        # одновременно удаляя элемент из кучи
        frequency_1, _, left = heapq.heappop(heap_queue)
        # получаем следующий наименьший элемент
        frequency_2, _, right = heapq.heappop(heap_queue)

        # добавляем в кучу новый элемент с частотой равной сумме первых двух,
        # счетчиком и новым узлом
        heapq.heappush(heap_queue, (frequency_1 + frequency_2, count, Node(left, right)))

        # уменьшаем счетчик
        count -= 1

    # в итоге в куче должен остаться один элемент, который и будет корнем (root)
    _, _, root = heap_queue.pop()

    # создаем пустой словарь для хранения кодов
    codes_table = {}

    # кодируем
    root.encode(codes_table, '')

    # выведем таблицу
    print('Таблица кодов:')
    for key, value in codes_table.items():
        print(f'{key} : {value}')

    # выводим строку согласно таблице кодов
    print('\nРезультат: ')
    for i in range(len(source_str)):
        print(f'{codes_table[source_str[i]]}', end=' ')


# исходная строка
SOURCE_STR = 'beep boop beer!'

# вызовем функцию для обработки исходной строки
huffman(SOURCE_STR)


"""
wiki:
Классический алгоритм Хаффмана на входе получает таблицу частот встречаемости символов в сообщении. 
Далее на основании этой таблицы строится дерево кодирования Хаффмана (Н-дерево).

1) Символы входного алфавита образуют список свободных узлов. Каждый лист имеет вес, который может 
быть равен либо вероятности, либо количеству вхождений символа в сжимаемое сообщение.
2) Выбираются два свободных узла дерева с наименьшими весами.
3) Создается их родитель с весом, равным их суммарному весу.
4) Родитель добавляется в список свободных узлов, а два его потомка удаляются из этого списка.
5) Одной дуге, выходящей из родителя, ставится в соответствие бит 1, другой — бит 0. Битовые значения 
ветвей, исходящих от корня, не зависят от весов потомков.
6) Шаги, начиная со второго, повторяются до тех пор, пока в списке свободных узлов не останется 
только один свободный узел. Он и будет считаться корнем дерева.


От себя:
В методичке и в википедии алгоритм описан некорректно. Т.к. в условии нигде не указано на какую
позицию должен вставать новообразованный узел, при наличии равенства повторений между соседними
элементами.
Т.е. в случае, если у нас ближайшие элементы имеют частоту вхождения (1, 1, 2, 2, 2),
то при сложении частот первых двух элементов, мы можем узел (без уточнения) вставить
на любую позицию посреди элементов на позициях 3,4 и 5 (2,2,2).
Изначально я добавлял обратно элемент в кучу в конец подобной последовательности, поэтому
'count' был равен длине последовательности и увеличивался, чтобы избежать ошибок.
Однако, вывод был совершенно некорректный. После проверки иллюстраций и идеи о том, что новый узел
должен вставать на первое место подобной последовательности (с одинаковой частотой), решение
получилось корректным.
Также в методичке перепутаны местами символы 'o' и ' ' в дереве.
Соответственно пример там некорректный, как и коды этих символов.
"""
