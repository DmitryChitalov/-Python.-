# Задание №1
# Алгоритм
# В одномерном массиве найти сумму элементов,
# находящихся между минимальным и максимальным элементами.
# Сами минимальный и максимальный элементы в сумму не включать.

from random import random

# Создаем массив случайных значений заданой длины
size = 100000
list = [int(random() * 30) for i in range(0, size)]


# первая реализация алгоритма Рассмотри функцию sum_around1 Находить индексы максимального и минимального элементов,
# после чего высчитвает сумму между ними Чтобы найти максимальный или минимальный элемент нужно пройти один раз по
# всему списку слодность O(n), где n - длина списка, нахождение индекса O(1)
# range(x, y) - имеет сложность O(k) - где k = x-y, но я не уверен ведь range() создает список, который мы применяем
def sum_around1(list):
    max_id = list.index(min(list))  # O(n)
    min_id = list.index(max(list))  # O(n)
    if min_id > max_id:
        min_id, max_id = max_id, min_id
    num = 0
    # O(k), при этом максимальный элемент может быть в начале а минимальный в конце O(n) - худший вариант
    for i in range(min_id + 1, max_id):
        num += list[i]
    return num


# В итоге сложность получилась O(3n)

# второая реализация алгоритма
# сложность O(n) - ведь максимальный и минимальный элемент уже передан
def sum_around2(list, min_id, max_id):
    if min_id > max_id:
        min_id, max_id = max_id, min_id
    num = 0
    for i in range(min_id + 1, max_id):
        num += list[i]
    return num


# разница, между алгоритмами в том, что вычисление где максимвльны, а где минимальный элемент в 1 проводится,
# а во втором нет
print(list)
print(sum_around1(list))
print(sum_around2(list, list.index(min(list)), list.index(max(list))))


