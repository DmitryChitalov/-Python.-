"""
1.	Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи.
Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.


ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""


"""
Задание_8. Матрица 5x4 заполняется вводом с клавиатуры кроме последних элементов строк.
Программа должна вычислять сумму введенных элементов каждой строки
и записывать ее в последнюю ячейку строки.
В конце следует вывести полученную матрицу.

[3, 3, 3, 3, 12]
[3, 3, 3, 3, 12]
[3, 3, 3, 3, 12]
[3, 3, 3, 3, 12]
[3, 3, 3, 3, 12]
"""

from random import randint
import numpy as np
import time
import memory_profiler



################   1 VARIANT  Вложенный цикл   ################

def matr_double_loop(num):
    seq = []
    for i in range(num):
        seq.append([randint(0, 10) for _ in range(4)])

    for i in range(num):
        seq[i].append(sum(seq[i]))

    for i in range(num):
        sum_row = 0
        for j in range(4):
            sum_row += seq[i][j]
        seq[i].append(sum_row)

    for rw in seq:
        for el in rw:
            print(f'{el:>4}', end='')
        print()



################   2 VARIANT  Обычный цикл   ################

def matr_common_loop(num):
    seq = [[randint(0, 10) for _ in range(4)] for _ in range(num)]

    for i in range(num):
        seq[i].append(sum(seq[i]))

    for rw in seq:
        print(rw)



################   3 VARIANT  NUMPY   ################

def dec(func):
    def prof_time(num):
        t11 = time.process_time()
        m11 = memory_profiler.memory_usage()

        func(num)

        t12 = time.process_time()
        m12 = memory_profiler.memory_usage()

        time_diff = t12 - t11
        mem_diff = m12[0] - m11[0]
        print(f"Выполнение matr_numpy_dec заняло {time_diff} сек and {mem_diff} Мб")
    return prof_time

# @memory_profiler.profile
@dec
def matr_numpy_dec(num):
    M = np.array([np.random.randint(10, size=4) for _ in range(num)])
    S = np.array([M.sum(axis=1)]).T
    M = np.append(M, S, axis=1)
    print(M)

# @memory_profiler.profile
def matr_numpy(num):
    M = np.array([np.random.randint(10, size=4) for _ in range(num)])
    S = np.array([M.sum(axis=1)]).T
    M = np.append(M, S, axis=1)
    print(M)



if __name__ == '__main__':

    matr_numpy_dec(1000000)

    # t1 = time.process_time()
    # m1 = memory_profiler.memory_usage()
    #
    # matr_double_loop(1000000)
    # matr_common_loop(1000000)
    # matr_numpy(1000000)
    #
    # t2 = time.process_time()
    # m2 = memory_profiler.memory_usage()
    #
    # time_diff = t2 - t1
    # mem_diff = m2[0] - m1[0]
    # print(f"Выполнение matr_numpy заняло {time_diff} сек and {mem_diff} Мб")




# Выполнение matr_double_loop заняло 37.890625 сек and 0.60546875 Мб
# Выполнение matr_common_loop заняло 13.9375 сек and 0.56640625 Мб
# Выполнение matr_numpy_dec заняло 18.34375 сек and 0.6875 Мб
# Выполнение matr_numpy заняло 18.5625 сек and 0.68359375 Мб
'''
(Python 3.8 32-bit; Windows 10x64; PyCharm 2019.3.2)

Самым затратным по времени и памяти оказался первый вариант, реализованный через вложенные
циклы.

Самый быстрый и экономичный по памяти - второй вариант с обычными циклами.
Однако дальнейший анализ показал, что основные затраты времени и памяти в первом варианте
были связаны с форматированием при выводе. Замена вывода на аналогичный со вторым вариантом
дала схожие показатели теста по времени и памяти: "Выполнение matr_double_loop заняло 14.578125 сек and 0.69140625 Мб".

Вариант с использованием библиотеки numpy несколько проигрывает во времени и по памяти.
Преимущество скорее всего в функционале, позволяющем писать кратко.
Две функции с numpy отличаются только наличием декоратора.
Одновременный запуск на тесте функции matr_numpy и декорированного варианта matr_numpy_dec
(последовательность функций менялась)
приводил к тому, что время выполнения было практически одинаковое, а памяти потреблялолсь
больше тем вариантом, который стоял в списке первым (несмотря на то, что для чистоты
эксперимента переменные m, t получили разные индексы: m1 - m11, t1 - t11).
Возможно, вариант, запускаемый первым, задействует модули time и memory_profiler,
поэтому потребление памяти у него больше. Хотя попытка обернуть функции дополнительно
в profile не показала инкремента памяти при запуске модулей.
При раздельном запуске функций тест выдавал одинаковые значения и по времени, и по
памяти с учетом погрешности. Эти раздельные замеры и приведены выше как более
объективные.
'''