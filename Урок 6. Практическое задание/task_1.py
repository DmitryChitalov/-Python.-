"""
1.	Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи.
Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.
ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

"""
Разрядность ОС и версия  Python:
Windows10 x64, Python 3.8
"""
import random
from memory_profiler import profile

"""
 1. Найти сумму и произведение цифр трехзначного числа,
которое вводит пользователь.
"""


@profile
def find_sum_mul_number():
    while True:
        try:
            number = int(input('Введите трехзначное целое положительное число: '))
            # Проверка, что введено трехзначное число
            # Если число введено отличное от трехзначного,
            # вызывается обработка исключения IOError
            if number < 100 or number > 999:
                raise IOError
        except ValueError:
            print('Ошибка ввода. Необходимо ввести трехзначное целое число.')
        except IOError:
            print('Неверно введено число. Необходимо ввести трехзначное целое число')
        else:
            # Определение цифр числа NUMBER путем
            # разбиения числа на сотни, десятки и единицы
            number_hundreds = number // 100
            number_tens = (number // 10) % 10
            number_units = number % 10
            # Вычисление суммы цифр числа NUMBER
            sum = number_hundreds + number_tens + number_units
            # Вычисление произведения цифр числа NUMBER
            multiplication = number_hundreds * number_tens * number_units
            return f'Сумма цифр числа =  {sum}\nПроизведение цифр числа =  {multiplication}'


"""
2.	Посчитать четные и нечетные цифры введенного натурального числа.
Например, если введено число 34560, то у него 3 четные цифры
(4, 6 и 0) и 2 нечетные (3 и 5).
Подсказка:
Для извлечения цифр числа используйте арифм. операции
Пример:
Введите натуральное число: 44
В числе 44 всего 2 цифр, из которых 2 чётных и 0 нечётных
ЗДЕСЬ ДОЛЖНА БЫТЬ РЕАЛИЗАЦИЯ ЧЕРЕЗ ЦИКЛ
"""


@profile
def find_even_uneven_numbers():
    # Словарь значений четных и нечетных цифр числа
    dict_numbers = dict()
    dict_numbers['четные'] = list()
    dict_numbers['нечетные'] = list()
    while True:
        try:
            number = int(input('Введите натуральное число:\n'))
            # Если введено отрицательное число генерируем обработку исключения
            if number < 0:
                raise IOError
        except (ValueError, TypeError, IOError):
            print('Ошибка ввода. Требуется ввести положительное целое число.')
        else:
            even_numbers = 0
            uneven_numbers = 0
            num = number
            while num > 0:
                unit_number = num % 10
                if unit_number % 2 == 0:
                    even_numbers += 1
                    if unit_number not in dict_numbers["четные"]:
                        dict_numbers["четные"].append(unit_number)
                else:
                    uneven_numbers += 1
                    if unit_number not in dict_numbers["нечетные"]:
                        dict_numbers["нечетные"].append(unit_number)
                num = num // 10
            for key, values in dict_numbers.items():
                print(f'{key}:   {values}')
            return f'В числе {number}:\nЧетных чисел =  {even_numbers}\nНечетных чисел = {uneven_numbers}'


"""
3.	Сформировать из введенного числа обратное по порядку входящих в него
цифр и вывести на экран. Например, если введено число 3486,
то надо вывести число 6843.
Подсказка:
Используйте арифм операции для формирования числа, обратного введенному
Пример:
Введите число: 123
Перевернутое число: 321
ЗДЕСЬ ДОЛЖНА БЫТЬ РЕАЛИЗАЦИЯ ЧЕРЕЗ ЦИКЛ
"""


@profile
def reverse_number():
    while True:
        try:
            number = int(input('Введите целое положительное число:\n'))
            if number < 0:
                raise IOError
        except (ValueError, TypeError, IOError):
            print('Ошибка ввода. Требуется ввести положительное целое число.')
        else:
            inverse_numb = 0
            num = number
            # Цикл выполняется пока поочередно перебирая цифры числа не дойдет до последней цифры
            while num > 0:
                # находим последнюю цифру числа
                # увеличиваем разрядность второго числа
                # добавляем очередную цифру к формируемому перевернутому числу
                inverse_numb = inverse_numb * 10 + num % 10
                # переходим к следующей цифре исходного числа
                num = num // 10
            return f'Исходное число: {number}\nПеревернутое число: {inverse_numb}'


"""
4. Во втором массиве сохранить индексы четных элементов первого массива.
Например, если дан массив со значениями 8, 3, 15, 6, 4, 2, то во второй массив
надо заполнить значениями 1, 4, 5, 6 (или 0, 3, 4, 5 - если индексация начинается с нуля),
т.к. именно в этих позициях первого массива стоят четные числа.
Подсказка:
Попробуйте решить эту задачу в одну строку (такое решение точно есть)
Пример:
Исходный массив: [8, 3, 15, 6, 4, 2], результат: [0, 3, 4, 5]
"""


@profile
def index_even_uneven():
    first_array = [random.randint(1, 100) for _ in range(11)]
    # Решение в одну строку
    second_array = [i for i in range(0, len(first_array)) if first_array[i] & 1 == 0]
    # Вывод исходного массива и результирующего массива с индексами четных элементов первого массива
    return f'Исходный массив: {first_array}\nРезультат: {second_array}'


"""
5. Алгоритм нахождения i-го по счёту простого числа.
Используя алгоритм «Решето Эратосфена»
"""


@profile
def eratosfen_method(max_number):
    a = [i for i in range(max_number * 100)]
    a[1] = 0
    i = 2
    while i < max_number * 100:
        if a[i] != 0:
            j = i * 2
            while j < max_number * 100:
                a[j] = 0
                j += i
        i += 1

    number = [i for i in a if i != 0]
    return number, f'{max_number} по счету простое число: {number[max_number - 1]}'


"""
6. Алгоритм нахождения i-го по счёту простого числа.
Без алгоритма «Решето Эратосфена»
"""


@profile
def simple_method(index):
    n = index
    lst = []
    first = 2
    while len(lst) != index:
        for i in range(first, n + 1):
            for j in range(2, i):
                if i % j == 0:
                    break
            else:
                lst.append(i)
        n += 1
        first = n
    return f'{index} по счету простое число: {lst[-1:]}'


print(f'{find_sum_mul_number()}')
print(f'{find_even_uneven_numbers()}')
print(f'{reverse_number()}')
print(f'{index_even_uneven()}')
MAX_NUMBER = 10
print(f'{eratosfen_method(MAX_NUMBER)[1]}')
print(f'{simple_method(MAX_NUMBER)}')

"""
Результаты:

****************************************************** Задача 1 ******************************************************
Введите трехзначное целое положительное число: 725
Сумма цифр числа =  14
Произведение цифр числа =  70

Line #    Mem usage    Increment   Line Contents
================================================
    27     13.6 MiB     13.6 MiB   @profile
    28                             def find_sum_mul_number():
    29                                 while True:
    30     13.6 MiB      0.0 MiB           try:
    31     13.7 MiB      0.0 MiB               number = int(input('Введите трехзначное целое положительное число: '))
    32                                         # Проверка, что введено трехзначное число
    33                                         # Если число введено отличное от трехзначного,
    34                                         # вызывается обработка исключения IOError
    35     13.7 MiB      0.0 MiB               if number < 100 or number > 999:
    36                                             raise IOError
    37                                     except ValueError:
    38                                         print('Ошибка ввода. Необходимо ввести трехзначное целое число.')
    39                                     except IOError:
    40                                         print('Неверно введено число. Необходимо ввести трехзначное целое число')
    41                                     else:
    42                                         # Определение цифр числа NUMBER путем
    43                                         # разбиения числа на сотни, десятки и единицы
    44     13.7 MiB      0.0 MiB               number_hundreds = number // 100
    45     13.7 MiB      0.0 MiB               number_tens = (number // 10) % 10
    46     13.7 MiB      0.0 MiB               number_units = number % 10
    47                                         # Вычисление суммы цифр числа NUMBER
    48     13.7 MiB      0.0 MiB               sum = number_hundreds + number_tens + number_units
    49                                         # Вычисление произведения цифр числа NUMBER
    50     13.7 MiB      0.0 MiB               multiplication = number_hundreds * number_tens * number_units
    51     13.7 MiB      0.0 MiB               return f'Сумма цифр числа =  {sum}\n Произведение цифр числа =  {multiplication}'

======================================================================================================================
Вывод: Функция не требует дополнительной памяти и нет необходимости в оптимизации.
Функция использует 13.7 МБайт памяти.
======================================================================================================================

 
****************************************************** Задача 2 ******************************************************
Введите натуральное число:
67342598937632
четные:   [2, 6, 8, 4]
нечетные:   [3, 7, 9, 5]

Line #    Mem usage    Increment   Line Contents
================================================
    67     13.7 MiB     13.7 MiB   @profile
    68                             def find_even_uneven_numbers():
    69                                 # Словарь значений четных и нечетных цифр числа
    70     13.7 MiB      0.0 MiB       dict_numbers = dict()
    71     13.7 MiB      0.0 MiB       dict_numbers['четные'] = list()
    72     13.7 MiB      0.0 MiB       dict_numbers['нечетные'] = list()
    73                                 while True:
    74     13.7 MiB      0.0 MiB           try:
    75     13.7 MiB      0.0 MiB               number = int(input('Введите натуральное число:\n'))
    76                                         # Если введено отрицательное число генерируем обработку исключения
    77     13.7 MiB      0.0 MiB               if number < 0:
    78                                             raise IOError
    79                                     except (ValueError, TypeError, IOError):
    80                                         print('Ошибка ввода. Требуется ввести положительное целое число.')
    81                                     else:
    82     13.7 MiB      0.0 MiB               even_numbers = 0
    83     13.7 MiB      0.0 MiB               uneven_numbers = 0
    84     13.7 MiB      0.0 MiB               num = number
    85     13.7 MiB      0.0 MiB               while num > 0:
    86     13.7 MiB      0.0 MiB                   unit_number = num % 10
    87     13.7 MiB      0.0 MiB                   if unit_number % 2 == 0:
    88     13.7 MiB      0.0 MiB                       even_numbers += 1
    89     13.7 MiB      0.0 MiB                       if unit_number not in dict_numbers["четные"]:
    90     13.7 MiB      0.0 MiB                           dict_numbers["четные"].append(unit_number)
    91                                             else:
    92     13.7 MiB      0.0 MiB                       uneven_numbers += 1
    93     13.7 MiB      0.0 MiB                       if unit_number not in dict_numbers["нечетные"]:
    94     13.7 MiB      0.0 MiB                           dict_numbers["нечетные"].append(unit_number)
    95     13.7 MiB      0.0 MiB                   num = num // 10
    96     13.7 MiB      0.0 MiB               for key, values in dict_numbers.items():
    97     13.7 MiB      0.0 MiB                   print(f'{key}:   {values}')
    98     13.7 MiB      0.0 MiB               return f'В числе {number}:\nЧетных чисел =  {even_numbers}\nНечетных чисел = {uneven_numbers}'


В числе 67342598937632:
Четных чисел =  6
Нечетных чисел = 8
======================================================================================================================
Вывод: Функция не требует дополнительной памяти и нет необходимости в оптимизации.
Функция использует 13.7 МБайт памяти без приращения.
======================================================================================================================


****************************************************** Задача 3 ******************************************************
Введите целое положительное число:
7867364266

Исходное число: 7867364266
Перевернутое число: 6624637687

Line #    Mem usage    Increment   Line Contents
================================================
   114     13.7 MiB     13.7 MiB   @profile
   115                             def reverse_number():
   116                                 while True:
   117     13.7 MiB      0.0 MiB           try:
   118     13.7 MiB      0.0 MiB               number = int(input('Введите целое положительное число:\n'))
   119     13.7 MiB      0.0 MiB               if number < 0:
   120                                             raise IOError
   121                                     except (ValueError, TypeError, IOError):
   122                                         print('Ошибка ввода. Требуется ввести положительное целое число.')
   123                                     else:
   124     13.7 MiB      0.0 MiB               inverse_numb = 0
   125     13.7 MiB      0.0 MiB               num = number
   126                                         # Цикл выполняется пока поочередно перебирая цифры числа не дойдет до последней цифры
   127     13.7 MiB      0.0 MiB               while num > 0:
   128                                             # находим последнюю цифру числа
   129                                             # увеличиваем разрядность второго числа
   130                                             # добавляем очередную цифру к формируемому перевернутому числу
   131     13.7 MiB      0.0 MiB                   inverse_numb = inverse_numb * 10 + num % 10
   132                                             # переходим к следующей цифре исходного числа
   133     13.7 MiB      0.0 MiB                   num = num // 10
   134     13.7 MiB      0.0 MiB               return f'Исходное число: {number}\nПеревернутое число: {inverse_numb}'

======================================================================================================================
Вывод: Функция не требует дополнительной памяти и нет необходимости в оптимизации.
Функция использует 13.7 МБайт памяти без приращения.
======================================================================================================================

****************************************************** Задача 4 ******************************************************
Исходный массив: [73, 1, 90, 19, 88, 10, 52, 9, 34, 71, 77]
Результат: [2, 4, 5, 6, 8]

Line #    Mem usage    Increment   Line Contents
================================================
   149     13.9 MiB     13.9 MiB   @profile
   150                             def index_even_uneven():
   151     13.9 MiB      0.0 MiB       first_array = [random.randint(1, 100) for _ in range(11)]
   152                                 # Решение в одну строку
   153     13.9 MiB      0.0 MiB       second_array = [i for i in range(0, len(first_array)) if first_array[i] & 1 == 0]
   154                                 # Вывод исходного массива и результирующего массива с индексами четных элементов первого массива
   155     13.9 MiB      0.0 MiB       return f'Исходный массив: {first_array}\nРезультат: {second_array}'

======================================================================================================================
Вывод: Функция не требует дополнительной памяти и нет необходимости в оптимизации.
Функция использует 13.9 МБайт памяти без приращения. Использование генератора дает преимущество
в экономии памяти.
======================================================================================================================


****************************************************** Задача 5 ******************************************************
10 по счету простое число: 29
================================================
   164     13.9 MiB     13.9 MiB   @profile
   165                             def eratosfen_method(max_number):
   166     13.9 MiB      0.0 MiB       a = [i for i in range(max_number * 100)]
   167     13.9 MiB      0.0 MiB       a[1] = 0
   168     13.9 MiB      0.0 MiB       i = 2
   169     13.9 MiB      0.0 MiB       while i < max_number * 100:
   170     13.9 MiB      0.0 MiB           if a[i] != 0:
   171     13.9 MiB      0.0 MiB               j = i * 2
   172     13.9 MiB      0.0 MiB               while j < max_number * 100:
   173     13.9 MiB      0.0 MiB                   a[j] = 0
   174     13.9 MiB      0.0 MiB                   j += i
   175     13.9 MiB      0.0 MiB           i += 1
   176                             
   177     13.9 MiB      0.0 MiB       number = [i for i in a if i != 0]
   178     13.9 MiB      0.0 MiB       return number, f'{max_number} по счету простое число: {number[max_number - 1]}'

======================================================================================================================
Вывод: Функция не требует дополнительной памяти и нет необходимости в оптимизации.
Функция использует 13.9 МБайт памяти без приращения. Использование генератора дает преимущество
в экономии памяти.
======================================================================================================================

****************************************************** Задача 6 ******************************************************
10 по счету простое число: [29]
================================================
   187     13.9 MiB     13.9 MiB   @profile
   188                             def simple_method(index):
   189     13.9 MiB      0.0 MiB       n = index
   190     13.9 MiB      0.0 MiB       lst = []
   191     13.9 MiB      0.0 MiB       first = 2
   192     13.9 MiB      0.0 MiB       while len(lst) != index:
   193     13.9 MiB      0.0 MiB           for i in range(first, n + 1):
   194     13.9 MiB      0.0 MiB               for j in range(2, i):
   195     13.9 MiB      0.0 MiB                   if i % j == 0:
   196     13.9 MiB      0.0 MiB                       break
   197                                         else:
   198     13.9 MiB      0.0 MiB                   lst.append(i)
   199     13.9 MiB      0.0 MiB           n += 1
   200     13.9 MiB      0.0 MiB           first = n
   201     13.9 MiB      0.0 MiB       return f'{index} по счету простое число: {lst[-1:]}'
   
======================================================================================================================
Вывод: Функция не требует дополнительной памяти и нет необходимости в оптимизации.
Функция использует 13.9 МБайт памяти без приращения. Использование генератора дает преимущество
в экономии памяти.
======================================================================================================================
"""
