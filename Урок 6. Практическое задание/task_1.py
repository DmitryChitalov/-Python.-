"""
1.	Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи.
Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.


ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
# Ubuntu 18.04.4 LTS x86_64
# Python 3.6.9


from memory_profiler import profile
from random import randint


# В одномерном массиве найти сумму элементов,
# находящихся между минимальным и максимальным элементами.
# Сами минимальный и максимальный элементы в сумму не включать.
@profile
def test():
    a = [randint(-100, 100) for x in range(1, 100000)]
    # print(a) это не принципиальный вывод, можно убрать

    result = 0
    min_idx = 0
    max_idx = 0
    for i in range(1, len(a)):
        if a[i] < a[min_idx]:
            min_idx = i
        elif a[i] > a[max_idx]:
            max_idx = i
    if min_idx > max_idx:
        min_idx, max_idx = max_idx, min_idx
    for i in range(min_idx + 1, max_idx):
        result += a[i]
    print(result)
    print(a[min_idx], a[max_idx])
    del a


test()


# в условии задачи стоит поиск суммы чисел между максимальным и минимальным
# соответственно после выполнения функции сам массив можно удалить и высвободить 2.7 MiB памяти
# а так же можно убрать принт массива после генерации и освободить еще 0.1 Mib

@profile
def test_2():
    a = []
    b = []
    for i in range(1, 100000):
        a.append(randint(0, 100))
    for j in range(0, len(a)):
        if a[j] % 2 == 0:
            b.append(j)
    print(b)


test_2()


@profile
def test_2_2():
    a = []
    b = []
    for i in range(1, 100000):
        a.append(randint(0, 100))
    for j in range(0, len(a)):
        if a[j] % 2 == 0:
            b.append(j)
    print(b)
    del b
    del a


test_2_2()


# удалив уже не нужные списки, удалось сэкономить 2.7 MiB
@profile
def test_3():
    a = [randint(0, 100) for x in range(1, 100000)]
    b = [x for x in range(0, len(a)) if a[x] % 2 == 0]
    print(b)
# Если написать сразу  print([x for x in range(0, len(a)) if a[x] % 2 == 0])
# так же можно выйграть немного памяти

test_3()


# Заменив цикл генератором прибавку в памяти не заметил

@profile
def test_4():
    a = [randint(0, 100) for x in range(1, 100000)]
    b = tuple([x for x in range(0, len(a)) if a[x] % 2 == 0])
    print(b)


test_4()

# Заменив список на кортеж удалось освободить 0.1 MiB, но если список был бы длиннее,
# можно было бы высвободить больше памяти
