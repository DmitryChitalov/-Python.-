"""
1.	Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи.
Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.


ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Windows 10 x64, Python 3.8
"""
from memory_profiler import profile
from pympler import asizeof


@profile
def nums(number):
    numb_even = 0
    numb_odd = 0
    new_numb = number
    while new_numb > 0:
        if (new_numb % 10) % 2 == 0:
            numb_even += 1
        else:
            numb_odd += 1
        new_numb = new_numb // 10
    return f"В числе {number} всего {len(str(number))} цифр, "\
           f"из которых {numb_even} чётных и {numb_odd} нечетных"


numb = 3456046


@profile
def recursion_nums(num, odd=0, even=0):
    """Проверка на четность и нечетность цифр в числе"""
    res_num = num % 10
    if res_num % 2 == 0:
        even += 1
    else:
        odd += 1
    num //= 10
    if num == 0:
        return print(f"Количество четных и нечетных цифр в числе равно: ({even}, {odd})")
    return recursion_nums(num, odd, even)


"""
Для задания 2 урока №4 было проверено две реализации: рекурсивная и через счетчик
в обоих случаях прироста занимаемой памяти не обнаружено, следовательно, обе реализации программы 
считаются эффективными в плане потребления памяти.
Размер функции проверки на четность и нечетность цифр рекурсивным методом: 8 bytes
Размер функции проверки на четность и нечетность цифр: 168 bytes
Рекурсивный метод будет предпочтительнее.
"""


@profile
def number():
    for i in range(2, 10):
        count = 0
        for j in range(2, 100):
            if not j % i:
                count += 1
        print(f"В диапазоне 2-99: {count} чисел кратны {i}")


print(f"Размер функции проверки на четность и нечетность цифр "
      f"рекурсивным методом: {asizeof.asizeof(recursion_nums(numb))} bytes")
print(f"Размер функции проверки на четность и нечетность цифр: {asizeof.asizeof(nums(numb))} bytes")


@profile
def func():
    # Счетчик элементов в строке
    TAB = 0
    # Начальный элемент таблицы ASCII
    C = 32
    # Строка для вывода результата
    RESULT = ''
    for i in range(32, 128):
        RESULT += f'{C} - {chr(C)} '
        C += 1
        TAB += 1
        # Добавление перевода строки после десятого элемента
        if TAB % 10 == 0:
            RESULT += '\n'
    print(RESULT)


@profile
def recursion_alphabet(c=32, result='', tab=0):
    """
    Вывод элементов таблицы ASCII через рекурсию
    """
    # Строка для вывода результата
    result += f'{c} - {chr(c)} '
    # Добавление к  начальному элементу таблицы ASCII
    c += 1
    # Добавление к счетчику элементов в строке для перевода строки
    tab += 1
    # Добавление перевода строки после десятого элемента
    if tab % 10 == 0:
        result += '\n'
    if c == 128:
        return print(result)
    return recursion_alphabet(c, result, tab)


print(f"Размер функции вывода элементов таблицы ASCII: {asizeof.asizeof(func())} bytes")
print(f"Размер функции вывода элементов таблицы ASCII "
      f"рекурсивным методом:{asizeof.asizeof(recursion_alphabet(c=32, result='', tab=0))} bytes")

"""
В задании №5 2-го урока было проверено две реализации функции: через конкатенацию и рекурсию.
В случае конкатенации и рекурсии размер функции вывода элементов таблицы ASCII 8 bytes.
Но на каждом цикле рекурсии идет небольшой прирост в размере 0.1 MiB, что я считаю 
незначительным значением. Поэтому обе реализации программы имеют право на существование. 
"""
