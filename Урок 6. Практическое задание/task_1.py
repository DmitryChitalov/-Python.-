"""
1.	Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи.
Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.


ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
"""
Задание_3.	В массиве случайных целых чисел поменять
местами минимальный и максимальный элементы.

Пример:
В данном массиве чисел максимальное число   88 стоит на
0 позиции, а минимальное число  -49 стоит на    6 позиции
Заменяем их
[88, 26, 41, 75, 23, 52, -49, 60, 69, -18]
В данном массиве чисел максимальное число   88 стоит на
6 позиции, а минимальное число  -49 стоит на    0 позиции
[-49, 26, 41, 75, 23, 52, 88, 60, 69, -18]
"""
from random import randint
from memory_profiler import profile
from pympler import asizeof
from guppy import hpy
import numpy as np


@profile
def task_3(l):
    min_el = 0
    max_el = 0
    cnt = 0
    # for el in l[1:]:
    #     cnt += 1
    #     if el < l[min_el]:
    #         min_el = cnt
    #     elif el > l[max_el]:
    #         max_el = cnt
    for el in l:
        if el < l[min_el]:
            min_el = cnt
        elif el > l[max_el]:
            max_el = cnt
        cnt += 1

    print(f'Исходный список:   {l}, минимальный элемент - {l[min_el]}, '
          f'максимальный элемент- {l[max_el]}')
    l[min_el], l[max_el] = l[max_el], l[min_el]
    print(f'Измененный список: {l}')


h = hpy()
l = [randint(-100, 100) for _ in range(50000)]
task_3(l)
print(h.heap())
#
# # В силу того, что список крайне мал - сложно что-то оптимизировать.
# # Но возможно, если после вычисления мин. и макс. числа и замены исходного списка
# # его необходимо будет хранить - можно преобразовать его в кортеж, хоть и выигрыш по объему данных невелик:
# print(asizeof.asizeof(l)) # 121336
# l = tuple(l)
# print(asizeof.asizeof(l)) # 118344
# # Либо же если целью скрипта является разовое вычисление, тогда удалить список
# del l
# # Так же при использовании среза создается копия списка, по которому проходит цикл
# #     38     19.0 MiB      0.4 MiB       for el in l[1:]:
# # Если переписать без использования среза, то освобождается часть памяти
# #     44     18.6 MiB      0.0 MiB       for el in l:

"""
Задание_6.	В одномерном массиве найти сумму элементов,
находящихся между минимальным и максимальным элементами.
Сами минимальный и максимальный элементы в сумму не включать.

Подсказки:
1) берем первый минимальный и максимальный
2) не забудьте, что сначала может быть минимальный, потом максимальный
а может - наоборот. во всех этих случаях нужна корректная работа

Пример:
Введите количество элементов в массиве: 10
Массив: [88, 58, 50, 77, 49, 6, 42, 67, 14, 79]
Сумма элементов между минимальным (6)  и максимальным (88) элементами: 234
"""


@profile
def task_6(l):
    try:

        max_el = 0
        min_el = 0
        for i in range(len(l)):
            if l[i] > l[max_el]:
                max_el = i
            elif l[i] < l[min_el]:
                min_el = i
        if min_el > max_el:
            right, left = min_el, max_el
        else:
            right, left = max_el, min_el
        res = 0
        for el in l[left + 1:right]:
            res += el
        # print(f'Массив: {l}\nСумма элементов между минимальным ({l[min_el]}) и '
        #       f'максимальным ({l[max_el]}) элементами: {res}' if res != 0 else
        #       f'В массиве {l} между минимальным ({l[min_el]}) '
        #       f'и максимальным ({l[max_el]}) элементом нет чисел')
        if res != 0:
            return f'Массив: {l}\nСумма элементов между минимальным ({l[min_el]}) и ' \
                   f'максимальным ({l[max_el]}) элементами: {res}'
        else:
            return f'В массиве {l} между минимальным ({l[min_el]} ' \
                   f'и максимальным ({l[max_el]}) элементом нет чисел'
    except ValueError:
        print('Необходимо ввести целое число')


h = hpy()
# n = int(input('Введите количество элементов в массиве: '))
n = 50000
l = [randint(0, 100) for _ in range(n)]
task_6(l)
print(h.heap())


# Здесь также можно добиться оптимизации либо удалением массива, либо изменением его на кортеж.
# Также при выводе внутри функции через print используется память:
#    109     17.4 MiB      0.0 MiB           print(f'Массив: {l}\nСумма элементов между минимальным ({l[min_el]}) и '
#    110     17.6 MiB      0.1 MiB                 f'максимальным ({l[max_el]}) элементами: {res}' if res != 0 else
#    111                                           f'В массиве {l} между минимальным ({l[min_el]}) '
#    112                                           f'и максимальным ({l[max_el]}) элементом нет чисел')
# При изменении функции и возвращении строки:
#    113     17.4 MiB      0.0 MiB           if res != 0:
#    114     17.4 MiB      0.0 MiB               return f'Массив: {l}\nСумма элементов между минимальным ({l[min_el]}) и ' \
#    115                                                f'максимальным ({l[max_el]}) элементами: {res}'
# Получается 0.1-0.2 MiB сохранить, но до конца не понимаю, в связи с чем это происходит.
# Почему при использовании функции print выделяется память на список, который уже создан.
# Если логически должно быть обращение к нему через ссылку. Возможно здесь играет роль погрешность измерения.
# Также примечательна разница в выделяемом объеме памяти на отрицательные числа
l = [randint(-100, 100) for _ in range(50000)]
print(asizeof.asizeof(l))  # 1164120
l = [randint(0, 100) for _ in range(50000)]
print(asizeof.asizeof(l))  # 409720
# Также отличным способом оптизимизации использовать numpy для хранения
# массивов.
l = np.array([randint(-100, 100) for _ in range(50000)])
print(asizeof.asizeof(l))  # 200096
l = np.array([randint(0, 100) for _ in range(50000)])
print(asizeof.asizeof(l))  # 200096
