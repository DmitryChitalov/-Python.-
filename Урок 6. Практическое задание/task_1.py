"""
1.	Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи.
Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.


ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

import memory_profiler
from pympler import asizeof
from SimpleMath import MathCalcSlots, MathCalcDict


# ----------------------------------- Task 1 ---------------------------------------
"""
Представлены две функции для нахождения простых чисел
При помощи решета Эратосфена
В первом случае возвращается весь список
Во втором случае используется генератор
Для каждого из них был произведен замер памяти
Все результаты представлены в текстовыз файлах
А графическая интерпреация в exel файле
Версия интерпретатора: Python 3.7
Версия pympler : 0.8
"""

# В варианте создется весь список целиком
# Поэтому для этого варианта толжно выделяться больше памяти
# С ростом количества элементов
# Учитывая что рост от n - линейный,
# То ожидаемо что память тоже будет выделяться линейно от n
def eratosfen(n):

    values = {i: True for i in range(2, n+1)}
    for key in values:
        if values[key]:
            k = 2
            while key*k <= n:
                values[key*k] = False
                k += 1
    return values

# Здесь используется генератор
# Затраты по выделению памяти должны быть миниимальными
# Учитывая что лишней памяти не выделяется, то
# следует ожидать некоторое флуктуационное поведение
# около некоторого среднего значения
def eratosfen_yield(n):
    values = {i: True for i in range(2, n+1)}
    for key in values:
        if values[key]:
            k = 2
            while key*k <= n:
                values[key*k] = False
                k += 1
            yield key

# Функция для подсчета выделенной памяти в вышеперечисленных функциях
def memory_check(function, end=900000):
    start = 10
    step = 1000
    name = str(function).split(" ")[1]
    with open(f"{name}.txt", "w", encoding='utf-8') as file:
        file.write("N\tMemory\n")
        while start <= end:
            m1 = memory_profiler.memory_usage()
            tmp = function(start)
            for el in tmp:
                pass
            m2 = memory_profiler.memory_usage()
            memory_use = m2[0] - m1[0]
            file.write(f"{start}\t{memory_use}\n")
            start += step
            del tmp

#memory_check(eratosfen_yield)
"""
Результаты замеров для функции без использования генератора
показывают ступенчато линейный рост памяти при росте исходной коллекции,
Ступенчатость может быть вызвана особенностью выделения памяти у компьютера
Однако независимо от этого наблюдается линейный рост памяти. Как и предсказывалось.

Для функции с генератором, как и ожидалось, наблюдаются флуктуации
около нуля (не среднего значения) так как исследовался только инкремент роста памяти,
а он является относительным значением
"""

"""
Учитывая предыдущие результаты по замерам времени работы для этого же метода
Можно сделать вывод что наиболее эффективно использовать решето, так как у него
временная зависимость O(N * ln(ln(N)), с использованием словарей вместо списков,
так как они работают быстрее, и для эффективного использования памяти использовать
генератор, так как он практически не задействует память компьютера
"""
# Результаты замеров для n = 899010
# Memory_result = 66,56640625 Mb , Memory_yield = 0,33984375 Mb

# ---------------------------------- Task 2 -------------------------------------

"""
Воспользуемя существующем файлом SimpleMath из предыдущего урока
класс MathCalc заменен на два отдельных: MathCalcDict и MathCalcSlots
Ничего не изменено, только в одном из классов применяются слоты
Проведем замеры памяти с использование слотов и без
"""

TMP_1 = MathCalcDict("C4F", 16)
TMP_2 = MathCalcSlots("C4F", 16)
MEM_1 = asizeof.asizeof(TMP_1)
MEM_2 = asizeof.asizeof(TMP_2)

print(f"Dict -> {MEM_1}, Slots -> {MEM_2}")
print(f"Difference = {MEM_1 - MEM_2}")

"""
Из результатов видно что выгоднее использовать слоты вместо стандартного словаря
так как они занимают меньше памяти
Данные могут отличаться в зависимости от версии и компьютера,
Но разница по занимаемой пямяти должна оставаться примерно в тех же порядках
"""

# В данном случае asizeof дает следующие результаты
# Dict = 1064, Slots = 736 , Diff = 328

