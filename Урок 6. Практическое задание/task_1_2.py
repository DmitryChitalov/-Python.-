"""
1.	Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи.
Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.


ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

# python version 3.7.3
# Windows 10, 64 bit

import memory_profiler
import random

"""
Задание_2. Во втором массиве сохранить индексы четных элементов первого массива.
Например, если дан массив со значениями 8, 3, 15, 6, 4, 2, то во второй массив
надо заполнить значениями 1, 4, 5, 6 (или 0, 3, 4, 5 - если индексация начинается с нуля),
т.к. именно в этих позициях первого массива стоят четные числа.

Подсказка:
Попробуйте решить эту задачу в одну строку (такое решение точно есть)

Пример:
Исходный массив: [8, 3, 15, 6, 4, 2], результат: [0, 3, 4, 5]
"""


@memory_profiler.profile
def even_number1(b):
    even_ind_lst = []
    for elem in b:
        if elem % 2 == 0:
            even_ind_lst.append(b.index(elem))


@memory_profiler.profile
def even_number2(b):
    even_ind_lst = [i for i, v in enumerate(b) if v % 2 == 0]


new_list = [random.randint(0, 99) for i in range(0, 900000)]

m1 = memory_profiler.memory_usage()

even_number1(new_list)

m2 = memory_profiler.memory_usage()

mem_diff = m2[0] - m1[0]

print(f"Выполнение заняло {mem_diff} Мб")

m3 = memory_profiler.memory_usage()

even_number2(new_list)

m4 = memory_profiler.memory_usage()

mem_diff2 = m3[0] - m4[0]

print(f"Выполнение заняло {mem_diff2} Мб")
"""
Line #    Mem usage    Increment   Line Contents
================================================
    17     18.2 MiB     18.2 MiB   @profile
    18                             def even_number1(b):
    19     18.2 MiB      0.0 MiB       even_ind_lst = []
    20     20.6 MiB      0.1 MiB       for elem in b:
    21     20.6 MiB      0.0 MiB           if elem % 2 == 0:
    22     20.6 MiB      0.4 MiB               even_ind_lst.append(b.index(elem))



Line #    Mem usage    Increment   Line Contents
================================================
    24     18.6 MiB     18.6 MiB   @profile()
    25                             def even_number2(b):
    26     27.1 MiB      0.4 MiB       even_ind_lst = [i for i, v in enumerate(b) if v % 2 == 0]


По результату в колонке "Mem usage" выходит, что больше памяти занимает втоая функция, но если смотреть по приростам,
то получается что первая функция в сумме дает больше прироста.
********************************************************************************************
Если смотреть через memory_usage, то получается что первая функция занимает больше памяти

Выполнение заняло 0.23046875 Мб
Выполнение заняло 0.0 Мб

"""
