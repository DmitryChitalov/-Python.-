"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

import timeit


def get_simple(border, num):
    nums = [i for i in range(2, border + 1)]
    dividers = []
    for element in nums:
        for divider in dividers:
            if element % divider == 0:
                break
        else:
            dividers.append(element)
    return dividers[num - 1]


def get_simple_era(border, num):
    a = [0] * (border + 1)  # создание массива с n количеством элементов
    for i in range(border + 1):  # заполнение массива ...
        a[i] = i  # значениями от 0 до n-1

    # вторым элементом является единица, которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0

    m = 2  # замена на 0 начинается с 3-го элемента (первые два уже нули)
    while m < border:  # перебор всех элементов до заданного числа
        if a[m] != 0:  # если он не равен нулю, то
            j = m * 2  # увеличить в два раза (текущий элемент простое число)
            while j < border:
                a[j] = 0  # заменить на 0
                j = j + m  # перейти в позицию на m больше
        m += 1
    dividers = []
    for i in a:
        if a[i] != 0:
            dividers.append(a[i])
    return dividers[num - 1]


print(
    f'реализация без использования Решета Эратосфена, порядковое число - 10\n'
    f'{timeit.timeit("get_simple(100, 10)", setup="from __main__  " "import get_simple", number=1000)}\n')


print(
    f'реализация с использованием Решета Эратосфенаб порядковое число - 10\n'
    f'{timeit.timeit("get_simple_era(100, 10)", setup="from __main__ import get_simple_era", number=100)}\n')

print(
    f'реализация без использования Решета Эратосфена, порядковое число - 100\n'
    f'{timeit.timeit("get_simple(550, 100)", setup="from __main__  " "import get_simple", number=100)}\n')

print(
    f'реализация с использованием Решета Эратосфенаб порядковое число - 100\n'
    f'{timeit.timeit("get_simple_era(550, 100)", setup="from __main__ import get_simple_era", number=100)}\n')


print(
    f'реализация без использования Решета Эратосфена, порядковое число - 1000\n'
    f'{timeit.timeit("get_simple(8000, 1000)", setup="from __main__  " "import get_simple", number=100)}\n')

print(
    f'реализация с использованием Решета Эратосфена, порядковое число - 1000\n'
    f'{timeit.timeit("get_simple_era(8000, 1000)", setup="from __main__  " "import get_simple_era", number=100)}\n')

# Были выполнены замеры на разных входных данных: 10, 100, 1000.
# реализация без использования Решета Эратосфена, порядковое число - 10
# 0.10828299999999999
# реализация с использованием Решета Эратосфенаб порядковое число - 10
# 0.005164699999999994
# реализация без использования Решета Эратосфена, порядковое число - 100
# 0.11721369999999998
# реализация с использованием Решета Эратосфенаб порядковое число - 100
# 0.07625929999999997
# реализация без использования Решета Эратосфена, порядковое число - 1000
# 12.7072201
# реализация с использованием Решета Эратосфена, порядковое число - 1000
# 1.2870069999999991
# В результате можно сделать вывод, что на более небольших значениях показатели времени алгоритмов примерно равные,
# а на больших - алгоритм с использованием Решета Эратосфена показывает лучшие результаты по времени, соответственно
# эффективнее
# Сложность алогритма с простой выборкой - O(n^2)
# Сложность алгоритма с использованием Решета - O(n*log(log n))
