"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

import timeit
from random import randint, sample


def find_min():
    lst = [randint(-100, 100) for i in range(10)]
    cnt = 0
    min1 = min(lst)
    for element in lst:
        if element == min1:
            cnt += 1
    if cnt > 1:
        return f'Наименьший элемент: {min1}, встречается в этом массиве {cnt} раз(а)'
    else:
        lst.remove(min1)
        min2 = min(lst)
        return f'Наименьший элемент: {min1}, встречается в этом массиве 1 раз \n' \
               f'Второй наименьший элемент: {min2}'


def find_min_modern():
    # Наполняем массив в при помощи random.sample
    lst = sample(range(-100, 100), 10)
    cnt = 0
    min1 = min(lst)
    for element in lst:
        if element == min1:
            cnt += 1
    if cnt > 1:
        return f'Наименьший элемент: {min1}, встречается в этом массиве {cnt} раз(а)'
    else:
        lst.remove(min1)
        min2 = min(lst)
        return f'Наименьший элемент: {min1}, встречается в этом массиве 1 раз \n' \
               f'Второй наименьший элемент: {min2}'


def find_min_modern_1():
    # Наполняем массив в при помощи random.sample
    lst = sorted(sample(range(-100, 100), 10))
    if lst[1] == lst[0]:
        return f'Наименьший элемент: {lst[0]}, встречается в этом массиве 2 раза'
    else:
        return f'Наименьший элемент: {lst[0]}, встречается в этом массиве 1 раз \n' \
               f'Второй наименьший элемент: {lst[1]}'


print(
    timeit.timeit(
        "find_min()",
        setup="from __main__ import find_min",
        number=10000))
print(
    timeit.timeit(
        "find_min_modern()",
        setup="from __main__ import find_min_modern",
        number=10000))
print(
    timeit.timeit(
        "find_min_modern_1()",
        setup="from __main__ import find_min_modern_1",
        number=10000))

# Было проведено 5 замеров. При количестве замеров 10000, программа выполняется за
# 0.18960549999999998, 0.1696744, 0.1770125 , 0.1842265 , 0.190231 при заполнении массива генератором и
# 0.17890259999999997, 0.1378096, 0.1621895, 0.18070379999999997, 0.20094520000000002 при
# наполнении через метод sample, что уменьшает время загрузки. Погрешность - 1 замер из 5
# 0.15565489999999998, 0.1234614, 0.14735810000000005, 0.17865220000000004, 0.15416999999999997
# В 3 случае время выполнения показало наилучшие результаты, так как работа проходила с сортированным списком и не
# нужно было проходить циклом по нему, а лишь достать необходимые позиции
# элементов


def get_reverse_num(num):
    """
    Реализация через цикл
    """
    reverse_num = ''
    while num > 0:
        digit = str(num % 10)
        reverse_num += digit
        num //= 10
    return int(reverse_num)


def get_reverse_num_modern(num):
    """
    Реализация через цикл
    """
    reverse_num = ''
    while num > 0:
        reverse_num += f"{str(num%10)}"
        num //= 10
    return int(reverse_num)


def get_reverse_num_recurse(num, reverse_num):
    """
    Реализация через рекурсию
    """
    if num <= 0:
        return reverse_num
    else:
        reverse_num += f"{num % 10}"
        return get_reverse_num_recurse(num // 10, reverse_num)


reverse_num = ''
for num in [4768, 78971624, 89091828457, 120982017581128201]:
    print(
        f'реализация цикл секунды {timeit.timeit("get_reverse_num(num)", setup="from __main__  " "import get_reverse_num, num", number=100000)}\n'
        f'реализация улучшенного цикла секунды {timeit.timeit("get_reverse_num_modern(num)", setup="from __main__  import get_reverse_num_modern, num ", number=100000)}\n'
        f'реализация рекурсией секунды {timeit.timeit("get_reverse_num_recurse(num, reverse_num)", setup="from __main__  import get_reverse_num_recurse, num, reverse_num ", number=100000)}\n')

# Данные по времени загрузки программы: при использовании цикла, число 4768:
# 0.24285850000000003, 0.3182747, 0.2889914, 0.3448729, 0.28603819999999996
# После оптимизации цикла:
# 0.2588024000000001, 0.3519356000000001, 0.3247333, 0.39836839999999996, 0.26539389999999996
# При использовании рекурсии:
# 0.252533, 0.2544868, 0.2440758999999999, 0.26763209999999993, 0.24148709999999995

# Данные по времени загрузки программы: при использовании цикла, число 78971624:
# 0.5355843, 0.5403406, 0.5129166999999999, 0.6680553999999999, 0.49140439999999996
# После оптимизации цикла:
# 0.5015925000000001, 0.5112031000000001, 0.4935575000000001, 0.5222691000000004, 0.5171930999999999
# При использовании рекурсии:
# 0.4102272, 0.5051141000000001, 0.45858259999999973, 0.4581032999999999, 0.48349600000000015

# Данные по времени загрузки программы: при использовании цикла, число 89091828457:
# 0.6200730999999999, 0.7152582999999999, 0.7163225999999998, 0.6746927999999999, 0.6512414
# После оптимизации цикла:
# 0.5818224999999999, 0.6796952000000003, 0.7074928000000003, 0.6701275, 0.6345403000000003
# При использовании рекурсии:
# 0.5451011999999995, 0.6624078999999998, 0.6441835999999999, 0.6438749999999995, 0.5992530999999994

# Данные по времени загрузки программы: при использовании цикла, число 120982017581128201:
# 0.9078417000000005, 1.1836107, 1.3295651000000008, 1.1575292, 0.9997476000000001
# После оптимизации цикла:
# 0.9554757999999994, 1.1518274000000002, 1.1907930000000002, 1.0884526, 1.1228129999999998
# При использовании рекурсии:
# 1.0546344999999997, 1.0893806000000001, 1.1367759000000008, 1.1572657000000008, 0.9555165000000008

# Выводы: Было сделано 5 замеров, после чего можно сделать вывод, что пользование рекурсией числа любой длины
# выполняется быстрее циклов. Оптимизированный цикл работает медленнее начального на небольших значениях (допускаются
# погрешности 1 из 5 замеров в других запусках), а на более высоких значениях быстрее, таким образом - заполнение
# list работает быстрее генераторов.
